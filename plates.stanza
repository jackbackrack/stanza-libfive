defpackage plates :
  import core
  import math
  import collections
  import utils
  import geom
  import ao

val big = 1.0e6f

public defn join-two-pieces (a:Shape, b:Shape, get-slots-info:(Float, Float) -> [Int, Float, Float]) -> [Shape, Shape] :
  val overlap   = intersection $ [a, b]
  val dims      = dims(bounds(overlap))
  val idx       = max-idx(dims)
  val [inslots, slot-off, slot-size] = get-slots-info(lo(bounds(overlap))[idx], dims[idx])
  val nslots    = inslots when inslots > 0 else to-int $ ceil $ dims[idx] / slot-size 
  val num       = to-int $ round $ (to-float(nslots) / 2.0f)
  val slot-dim  = (dims[idx] / to-float(nslots)) when inslots >= 0 else slot-size
  println-all(["INSLOTS " inslots " NSLOTS " nslots " SLOT-SIZE " slot-size " SLOT-DIM " slot-dim " NUM " num])
  val tdims     = set-elt(V3f-fill(big),  idx, slot-dim)
  val vslot-off = set-elt(V3f-fill(0.0f), idx, (- slot-off))
  val tooth     = cube(tdims)
  val tooths    = union $ stack-idx(slot-dim * to-float(nslots), idx, glue-when(nslots % 2 == 0, seq({ tooth }, 0 to num)))
  ;; println-all(["NUM " num " NSLOTS " nslots " IDX " idx " DIMS " dims " TDIMS " tdims[idx]])
  val teeth     = overlap & mov(center(bounds(overlap)) + vslot-off, tooths)
  val pa        = rem(a, teeth)
  val pb        = rem(b, pa)
  [pa, pb]

public defn join-two-pieces (a:Shape, b:Shape, num-slots:Int) -> [Shape, Shape] :
  join-two-pieces(a, b, fn (o:Float, s:Float) : [num-slots 0.0f, 0.0f])

public defn all-combos (a:Seqable<Int>, b:Seqable<Int>) -> Seqable<[Int, Int]> :
  generate<[Int, Int]> :
    for i in a do :
      for j in b do :
        yield([i, j])

val EPS = 0.001f

public defn full-captured-on? (i:Box, a:Box, d:Int) :
  ;; val res = abs(lo(i)[d] - lo(a)[d]) > EPS and abs(hi(a)[d] - hi(i)[d]) > EPS
  val res = (lo(i)[d] - lo(a)[d]) > EPS and (hi(a)[d] - hi(i)[d]) > EPS
  ;; println-all(["CAPTURED-ON? " i " / " a " D " d " -> " res])
  res

public defn captured? (b1:Box, b2:Box) -> True|False :
  defn any-captured? (i:Box, a:Box, big-d:Int) :
    val res = any?(full-captured-on?{i, a, _}, filter({ _ != big-d}, 0 to 3))
    ;; println-all(["ANY-CAPTURED? " i " / " a " big-d " big-d " -> " res])
    res
  val intersection = b1 & b2
  val big-d = max-idx(dims(intersection))
  any-captured?(intersection, b1, big-d) and any-captured?(intersection, b2, big-d)

defn n-smalls (dims:V3f) :
  val elts = to-tuple $ lazy-qsort(seq(get{dims, _}, 0 to 3))
  val n    = for d in 1 to 3 count : abs(elts[0] - elts[d]) < EPS
  n + 1

public defn full-captured2d? (b1:Box, b2:Box) -> True|False :
  if n-smalls(dims(b1 & b2)) == 1 :
    val i = b1 & b2
    val [d0, d1] = [mid-idx(dims(i)), max-idx(dims(i))]
    val c0 = (full-captured-on?(i, b1, d0) and full-captured-on?(i, b2, d1))
    val c1 = (full-captured-on?(i, b1, d1) and full-captured-on?(i, b2, d0))
    c0 or c1
  else :
    false

public defn abutt-captured-on? (a:Box, b:Box, d:Int, dir:Int) :
  val hi? = lo(b)[d] - lo(a)[d] > EPS and abs(hi(b)[d] - hi(a)[d]) < EPS
  val lo? = abs(lo(b)[d] - lo(a)[d]) < EPS and hi(a)[d] - hi(b)[d] > EPS
  val res = lo? when dir == -1 else hi?
  ;; println-all(["  PARTIAL-CAPTURED-ON? D " d " DIR " dir " A " a " B " b " RES " res])
  res

public defn abutt-captured-on? (a:Box, b:Box, d:Int) :
  val res = (lo(b)[d] - lo(a)[d]) > (- EPS) and (hi(a)[d] - hi(b)[d]) > (- EPS)
  ;; println-all(["  PARTIAL-CAPTURED-ON? D " d " A " a " B " b " RES " res])
  res

public defn abutt-captured2d? (b1:Box, b2:Box) -> True|False :
  val i = b1 & b2
  if n-smalls(dims(i)) == 1 :
    val [d0, d1] = [mid-idx(dims(i)), max-idx(dims(i))]
    val c0 = (abutt-captured-on?(b1, b2, d0) or abutt-captured-on?(b2, b1, d0))
    val c1 = (abutt-captured-on?(b1, b2, d1) or abutt-captured-on?(b2, b1, d1))
    ;; println-all(["ABUTT-CAPTURED2D? DIMS(i) " dims(i) " N-SMALLS " n-smalls(dims(i)) " C0 " c0 " C1 " c1 " RES " (c0 and c1)])
    ;; println-all(["ABUTT-CAPTURED2D? C " c])
    c0 and c1
    ;; c
  else :
    false

public defn join-pieces (elts:Seqable<Shape>,
                         default-slot-info-getter:((Float, Float) -> [Int, Float, Float]),
                         slots-info-getters:Tuple<KeyValue<[Int,Int],((Float, Float) -> [Int, Float, Float])>>,
                         sames:Tuple<[Int, Int, V3f]>) :
  defn lookup-slot-info-getter (i:Int, j:Int) -> ((Float,Float) -> [Int, Float, Float]) :
    label<((Float,Float) -> [Int, Float, Float])> return :  
      for kv in slots-info-getters do :
        val [ki, kj] = key(kv)
        if (ki == i and kj == j) or (ki == j and kj == i) :
          return(value(kv))
      default-slot-info-getter
  val pieces = to-array<Shape> $ elts
  defn update (k:Int, nk:Shape) :
    pieces[k] = nk
    for [i, j, d] in sames do :
      if i == k :
        println-all(["SAME UPDATE " j " <- " i])
        pieces[j] = pieces[j] & mov(d, pieces[i])
  defn run (ok?:(Box, Box) -> True|False, slot-info-getter:(Int, Int) -> ((Float, Float) -> [Int, Float, Float])) :
    for i in 0 to length(pieces) do :
      for j in (i + 1) to length(pieces) do : 
        val [bi, bj] = [bounds(pieces[i]), bounds(pieces[j])]
        if not empty?(bi & bj) :
          if ok?(bi, bj) :
            ;; print-all(["I " i " J " j " "])
            val [ni, nj] = join-two-pieces(pieces[i], pieces[j], slot-info-getter(i, j))
            update(i, ni)
            update(j, nj)
  run({ not captured?(_, _) }, lookup-slot-info-getter{_, _})
  run(captured?, fn (i:Int, j:Int) : (fn (o:Float,s:Float) : [2, 0.0f, 0.0f]))
  pieces

defn split-full-overlap (s0:Shape, s1:Shape, t:Float) -> [Shape, Shape] :
  val i = bounds(s0) & bounds(s1)
  val d = max-idx(dims(bounds(s0)))
  val o = dims(i)[d] / 3.0f
  val s0a = s0 & box(Box(lo(bounds(s0)), set-elt(hi(bounds(s0)), d, lo(i)[d] + o)))
  val s0b = s0 & box(Box(set-elt(lo(bounds(s0)), d, hi(i)[d] - o), hi(bounds(s0))))
  [s0a s0b]

defn split-abutt-overlap (i0:Int, s0:Shape, i1:Int, s1:Shape, t:Float) -> [Int, Shape] :
  val i   = bounds(s0) & bounds(s1)
  val d0  = mid-idx(dims(i))
  val d1  = max-idx(dims(i))
  ;; println-all(["SHAPES S0 " bounds(s0) " S1 " bounds(s1)])
  val [dir, d, k, s] = label<[Int, Int, Int, Shape]> return :
    for (a in [s0, s1], b in [s1, s0], k in [i0, i1]) do :
      for d in [d0, d1] do :
        for dir in [-1, 1] do :
          if abutt-captured-on?(bounds(a), bounds(b), d, dir) :
            ;; println-all(["FOUND ABUTTMENT D " d " DIR " dir " K " k])
            return([dir, d, k, a])
    println-all(["FAILED TO FIND ABUTTMENT"])
    ;; ASSERT FAILURE
    [-1, d0, i0, s0]
  val o   = dims(i)[d] / 3.0f
  val nsh = s & box(Box(lo(bounds(s)), set-elt(hi(bounds(s)), d, lo(i)[d] + o)))
  val nsl = s & box(Box(set-elt(lo(bounds(s)), d, hi(i)[d] - o), hi(bounds(s))))
  val ns  = nsl when dir == -1 else nsh
  [k, ns]

public defn split-overlaps (elts:Seqable<Shape>, t:Float) -> Seqable<Shape> :
  val pieces = to-vector<Shape> $ elts
  println-all(["SPLIT-OVERLAPS IN " length(pieces)])
  for (i in 0 to false, piece in pieces) do :
    println-all([i "  " bounds(piece)])
  let loop () :
    val restart? = label<True|False> restart:
      for i in 0 to length(pieces) do :
        for j in (i + 1) to length(pieces) do :
          val [bi, bj] = [bounds(pieces[i]), bounds(pieces[j])]
          ;; println-all(["I " i " J " j " BI " bi " BJ " bj])
          if not empty?(bi & bj) :
            ;; println-all(["CHECKING " i " AND " j])
            if full-captured2d?(bi, bj) :
              val [a, b] = split-full-overlap(pieces[i], pieces[j], t)
              println-all([  "  FULL SPLIT " bounds(a) " / " bounds(b)])
              pieces[i] = a
              add(pieces, b)
              restart(true)
            else if abutt-captured2d?(bi, bj) :
              val [k, a] = split-abutt-overlap(i, pieces[i], j, pieces[j], t)
              println-all([  "  ABUTT SPLIT K " k " " pieces[k] " -> " bounds(a)])
              pieces[k] = a
              restart(true)
      false
    if restart? : loop()
  ;; println-all(["  OUT " length(pieces)])
  pieces

defn quilt-one (s:Shape, mx:Float, d0:Int, d1:Int, t:Float) -> Seqable<Shape> :
  val bds   = bounds(s)
  val dms   = dims(bds)
  val n = to-int $ round(dms[d0] / (mx + 2.0f * t))
  val g = dms[d0] / to-float(n)
  val o = lo(bds)[d0]
  val [ni, phase] = [1, -0.5f] when d1 == 1 else [0, 0.0f]
  val res = to-tuple $ for i in 0 to (n + ni) seq :
    val l = o + ((to-float(i) + phase)     * g - t)
    val h = o + ((to-float(i + 1) + phase) * g + t)
    s & box(Box(set-elt(lo(bds), d0, l), set-elt(hi(bds), d0, h)))
  println-all(["SPLIT MX " mx " D0 " d0 " D1 " d1 " PHASE " phase " -> " to-tuple $ seq(bounds, res)])
  res

;;; SPLITS BIG PIECES INTO N PIECES ACCORDING TO 
public defn quilt (shape:Shape, stock-dims:V3f) -> Seqable<Shape> :
  val t = min(stock-dims)
  val shape-dims = dims(bounds(shape))
  val sorted-shape-dims = to-tuple $ lazy-qsort(shape-dims)  
  val sorted-stock-dims = to-tuple $ lazy-qsort(stock-dims)
  val cmps = to-tuple $ seq({1 when _ <= _ else 0}, sorted-shape-dims, sorted-stock-dims)
  val n = reduce(plus, cmps)
  println-all(["N " n " SHAPE-DIMS " sorted-shape-dims " STOCK-DIMS " sorted-stock-dims " CMPS " cmps])
  if n == 3 :
    [ shape ]
  else if n == 2 :
    quilt-one(shape, sorted-stock-dims[1], max-idx(shape-dims), mid-idx(shape-dims), t)
  else :
    val splits-0 = quilt-one(shape, sorted-stock-dims[2], max-idx(shape-dims), mid-idx(shape-dims), t)
    to-tuple $ cat-all $ seq(quilt-one{_, sorted-stock-dims[1], mid-idx(shape-dims), max-idx(shape-dims), t}, splits-0)

public defn join-pieces (elts:Seqable<Shape>, num:(Float,Float) -> [Int, Float, Float]) :
  join-pieces(elts, num, [], [])

;; TODO: LIMITED TO AXIS ALIGNED SHAPES
public defn smash (s:Shape) -> Shape :
  val bb    = bounds(s)
  val dims  = dims(bb)
  val idx   = min-idx(dims)
  val ctr   = center(bb)
  defn rot (s) : if idx == 0 : reflect-xz(s) else if idx == 1 : reflect-yz(s) else : s
  rot(mov((- ctr), s))

defn segment<?T> (shapes:Seqable<?T>, width:T -> Float, max-width:Float, space:Float) -> Seqable<Tuple<T>> :
  val row = Vector<T>()
  generate<Tuple<T>> :
    for pc in shapes do :
      val off = reduce(plus, 0.0f, join(seq(width, row), space))
      if off > max-width :
        yield(to-tuple $ row)
        clear(row)
      add(row, pc)
    if length(row) > 0 : yield(to-tuple $ row)

public defn nest (pcs:Seqable<Shape>, size:V3f, space:Float) -> Seq<Assembly> :
  val spcs  = to-tuple $ lazy-qsort({ area(dims(bounds(_))) }, pcs)
  val rpcs  = seq(fn (pc): reflect-xy(pc) when max-idx(dims(bounds(pc))) != max-idx(size) else pc, spcs)
  val rows  = to-tuple $ segment(rpcs, { x(dims(bounds(_))) }, x(size), space)
  val pages = segment(rows, { y(dims(bounds(union(_)))) }, y(size), space)
  for page in pages seq :
    val rrows = for row in page seq: Assembly(stack-x(join(row, spacer-x(space))))
    Assembly(stack-y(join(rrows, Assembly([ spacer-y(space) ]))))

defn num-to-bits (num:Int) -> Tuple<Int> :
  to-tuple $ for i in 2 through 0 by -1 seq : (num >> i) & 1

defn num-to-bitz (num:Int) -> Tuple<Tuple<Int>> :
  to-tuple $ for i in 2 through 0 by -1 seq : num-to-bits((num >> (i * 3)) & 7)

defn bits-to-num (bitz:Tuple<Int>) -> Int :
  reduce(fn (a, x): a * 2 + x, bitz)

defn bitz-to-num (bitz:Tuple<Tuple<Int>>) -> Int :
  reduce(fn (a, x): a * 8 + x, seq(bits-to-num, bitz))

defn canonicalize-bits (bits:Tuple<Int>) -> Tuple<Int> :
  val rbits = [bits[2], bits[1], bits[0]]
  if bits-to-num(bits) < bits-to-num(rbits): bits else: rbits

defn canonicalize-bitz (bitz:Tuple<Tuple<Int>>) -> Tuple<Tuple<Int>> :
  to-tuple $ seq(num-to-bits, lazy-qsort(seq(bits-to-num, seq(canonicalize-bits, bitz))))

defn check (form:Tuple<Tuple<Int>>) -> True|False :
  defn boxed? (dim:Int, idx:Int) :
    label<True|False> return :
      val dn? = for i in idx through 0 by -1 any? :
        form[dim][i] == 1
      val up? = for i in (idx + 1) to 3 any? :
        form[dim][i] == 1
      dn? and up?
  label<True|False> return :
    for i in 0 to 2 do :
      for j in 0 to 2 do :
        for k in 0 to 2 do :
          if boxed?(0, i) and boxed?(1, j) and boxed?(2, k) :
            return(false)
    true

public defn all-forms () :
  val forms = HashTable<Int, Tuple<Tuple<Int>>>()
  for i in 0 to (2 << 8) do :
    val bitz  = num-to-bitz $ i
    val cbitz = canonicalize-bitz $ bitz
    val cnum  = bitz-to-num $ cbitz
    val ok?   = count({ _ == 0}, seq(bits-to-num, cbitz)) <= 1
    val ck?   = check(cbitz)
    if ck? and ok? and not key?(forms, cnum) :
      ;; println-all(["I " i " CNUM " cnum " BITZ " bitz " CBITZ " cbitz " CK? " ck? " OK? " ok? " KEY? " key?(forms, cnum)])
      forms[cnum] = cbitz
  forms
