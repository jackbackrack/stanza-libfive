defpackage libfive :
  import core
  import math
  import collections
  import utils
  import glu
  import geom

val @doc-libfive = "## LIBFIVE -- distance fields"

lostanza deftype libfive_interval :
  lower : float
  upper : float

lostanza deftype libfive_region2 :
  X : libfive_interval
  Y : libfive_interval

lostanza deftype libfive_region3 :
  X : libfive_interval
  Y : libfive_interval
  Z : libfive_interval

lostanza deftype libfive_vec2 :
  x : float
  y : float

lostanza deftype libfive_vec3 :
  x : float
  y : float
  z : float

lostanza deftype libfive_vec4 :
  x : float
  y : float
  z : float
  w : float

lostanza deftype libfive_tri :
  a : int
  b : int
  c : int

lostanza deftype libfive_contour :
  pts : ptr<libfive_vec2>
  count : int

lostanza deftype libfive_contours :
  cs : ptr<libfive_contour>
  count : int

lostanza deftype LibfiveContours :
  value : ptr<libfive_contours>

lostanza deftype libfive_mesh :
  verts : ptr<libfive_vec3>
  tris : ptr<libfive_tri>
  tri-count : int
  vert-count : int

lostanza deftype LibfiveMesh :
  value : ptr<libfive_mesh>

lostanza deftype libfive_pixels :
  data : ptr<byte>
  width : int
  height : int

lostanza deftype LibfivePixels :
  value : ptr<libfive_pixels>

lostanza defn width (p:ref<LibfivePixels>) -> ref<Int> :
  return new Int{p.value.width}

lostanza defn height (p:ref<LibfivePixels>) -> ref<Int> :
  return new Int{p.value.height}

extern memcpy: (ptr<byte>, ptr<byte>, int) -> ptr<byte>

extern libfive_tree_x: () -> ptr<?>
extern libfive_tree_y: () -> ptr<?>
extern libfive_tree_z: () -> ptr<?>
extern libfive_tree_const: (float) -> ptr<?>
extern libfive_tree_unary: (int, ptr<?>) -> ptr<?>
extern libfive_tree_binary: (int, ptr<?>, ptr<?>) -> ptr<?>
extern libfive_opcode_enum: (ptr<?>) -> int
extern libfive_tree_delete: (ptr<?>) -> int
extern libfive_tree_eval_f_spread: (ptr<?>, float, float, float) -> float
;; extern libfive_tree_bounds_star: (ptr<?>) -> ptr<libfive_region3>
extern libfive_tree_print: (ptr<?>) -> ptr<byte>
extern libfive_tree_save: (ptr<?>, ptr<byte>) -> int
extern libfive_tree_save_mesh_spread: (ptr<?>, float, float, float, float, float, float, float, ptr<byte>) -> int
extern libfive_tree_save_slice_spread: (ptr<?>, float, float, float, float, float, float, ptr<byte>) -> int
extern libfive_tree_render_mesh_spread: (ptr<?>, float, float, float, float, float, float, float) -> ptr<libfive_mesh>
extern libfive_tree_render_slice_spread: (ptr<?>, float, float, float, float, float, float) -> ptr<libfive_contours>
extern libfive_tree_render_pixels_spread: (ptr<?>, float, float, float, float, float, float) -> ptr<libfive_pixels>
extern libfive_contours_delete: (ptr<libfive_contours>) -> int
extern libfive_mesh_delete: (ptr<libfive_mesh>) -> int
extern libfive_pixels_delete: (ptr<libfive_pixels>) -> int
extern printf: (ptr<?>, ? ...) -> int
extern free: (ptr<?>) -> int

public lostanza deftype Tree <: Geom :
  value: ptr<?>

defmethod print (o:OutputStream, t:Tree) :
  print-all(o, ["Tree()"])

public deftype FloField <: Equalable
public defmulti tree (f:FloField) -> Tree
public defmulti count (f:FloField) -> Int

public defstruct FloFieldLit <: FloField :
  tree: Tree with: (as-method => true)
  value: Float

defn lit? (f:FloField) -> True|False :
  match(f):
  (l:FloFieldLit) : true
  (o:FloFieldOp) : false

defn lit? (f:FloField, v:Float) -> True|False :
  match(f):
  (l:FloFieldLit) : value(l) == v
  (o:FloFieldOp) : false

defn op? (f:FloField, name:String) -> True|False :
  match(f):
  (l:FloFieldLit) : false
  (o:FloFieldOp) : name == op(o)

defn op-args (f:FloField) -> List<FloField> :
  match(f):
  (l:FloFieldLit) : List()
  (o:FloFieldOp) : args(o)

defn op-arg0 (f:FloField) -> FloField : op-args(f)[0]
defn op-arg1 (f:FloField) -> FloField : op-args(f)[1]

defn lit-value (f:FloField) -> Float :
  match(f):
  (l:FloFieldLit) : value(l)
  (o:FloFieldOp) : 0.0f

defmethod print (s:OutputStream, f:FloFieldLit) :
  print(s, "LIT(%_)" % [value(f)])

defmethod equal? (a:FloFieldLit, b:FloFieldLit) -> True|False :
  value(a) == value(b)

defmethod count (a:FloFieldLit) -> Int :
  1

public defstruct FloFieldOp <: FloField :
  tree: Tree with: (as-method => true)
  op: String
  args: List<FloField>

defmethod print (s:OutputStream, f:FloFieldOp) :
  print(s, "%_(%,)" % [op(f), args(f)])

defmethod equal? (a:FloFieldOp, b:FloFieldOp) -> True|False :
  op(a) == op(b) and all?(equal?, args(a), args(b))

defmethod count (f:FloFieldOp) -> Int :
  1 + reduce(i+, 0, seq(count, args(f)))

public defmulti mesh (s:Shape) -> False|Mesh
public defmulti mat (s:Shape) -> Mat44f
public defmulti cache (s:Shape) -> HashTable<Vec3Field,FloField>
public defmulti fabber (s:Shape) -> ((Vec3Field) -> FloField)
public defmulti set-mesh (s:Shape, m:Mesh) -> False

public defn Shape (fabber:(Vec3Field) -> FloField, mat:Mat44f, bounds:Box3f, state:AnyShapeState) :
  val cache = HashTable<Vec3Field,FloField>()
  var mesh:False|Mesh = false
  new Shape :
    defmethod bounds (this) : bounds
    defmethod state (this) : state
    defmethod fabber (this) : fabber
    defmethod mat (this) : mat
    defmethod cache (this) : cache
    defmethod mesh (this) : mesh
    defmethod set-mesh (this, m:Mesh) : mesh = m

public defn smash (s:Shape) -> Shape :
  xyz(inverse(mat(s)), s)

public defn Shape (fabber:(Vec3Field) -> FloField, mat:Mat44f, bounds:Box3f, name:False|Symbol, color:V4f, tags:Tuple<Symbol>, poses:Tuple<KeyValue<Symbol,Mat44f>>) :
  Shape(fabber, mat, bounds, AnyShapeState(name, color, tags, poses))

public defn Shape (fabber:(Vec3Field) -> FloField, bounds:Box3f) :
  Shape(fabber, id-mat44f(), bounds, false, WHITE, [], [])

public defn map (f:Shape -> Shape, m:Mat44f, p:Poseable) -> Poseable :
  match(p) :
    (a:Assembly) : Assembly(id-mat44f(), name(a), color(a), seq(map{f, mat(a) * m, _}, children(a)))
    (s:Shape) : f(xyz(m, s))

public defn map (f:Shape -> Shape, p:Poseable) -> Poseable :
  map(f, id-mat44f(), p)

defmethod clone (shape:Shape, state:AnyShapeState) -> Shape :
  Shape(fabber(shape), mat(shape), bounds(shape), state)

public defn Shape (s:Shape, mat:Mat44f, bounds:Box3f, name:False|Symbol, color:V4f, tags:Tuple<Symbol>, poses:Tuple<KeyValue<Symbol,Mat44f>>) :
  Shape(fabber(s), mat, bounds, name, color, tags, poses)

public defn Shape (s:Shape, bounds:Box3f) :
  Shape(s, mat(s), bounds, name(s), WHITE, tags(s), poses(s))

defn fab (s:Shape, p:Vec3Field) -> FloField :
  fabber(s)(p)
  ;; if key?(cache(s), p) :
  ;;   cache(s)[p]
  ;; else :
  ;;   val f = fabber(s)(p)
  ;;   cache(s)[p] = f
  ;;   ;; if length(cache(s)) > 1 :
  ;;   ;;   println-all(["MISS " to-tuple $ keys(cache(s))])
  ;;   f

defmethod print (s:OutputStream, o:Shape) :
  print-all(s, ["Shape(" bounds(o) ")"])

public deftype AnyTree <: Geom

public defstruct BoundedTree <: AnyTree :
  shape: Shape
  field: FloField

public defn bounds (t:BoundedTree) : bounds(shape(t))
public defn name (t:BoundedTree) : name(shape(t))
public defn tree (t:BoundedTree) : tree(field(t))
public defn mesh (t:BoundedTree) : mesh(shape(t))
public defn set-mesh (t:BoundedTree, m:Mesh) : set-mesh(shape(t), m)

public defstruct TreeAssembly <: AnyTree :
  name  : False|Symbol
  mat   : Mat44f
  color : V4f
  trees : Tuple<AnyTree>

public lostanza defn tree-delete (t:ref<Tree>) -> ref<False> :
  call-c libfive_tree_delete(t.value)
  return false

public lostanza defn tree-eval-f (t:ref<Tree>, p:ref<V3f>) -> ref<Float> :
  val res = call-c libfive_tree_eval_f_spread(t.value, x(p).value, y(p).value, z(p).value)
  return new Float{res}

public lostanza defn tree-print (t:ref<Tree>) -> ref<String> :
  val res = call-c libfive_tree_print(t.value)
  return String(res)

public lostanza defn tree-save (t:ref<Tree>, filename:ref<String>) -> ref<False> :
  call-c libfive_tree_save(t.value, addr!(filename.chars))
  return false

public lostanza defn tree-save-mesh (t:ref<Tree>, filename:ref<String>, box:ref<Box3f>, res:ref<Float>) -> ref<False> :
  call-c libfive_tree_save_mesh_spread(t.value, x(lo(box)).value, x(hi(box)).value, y(lo(box)).value, y(hi(box)).value, z(lo(box)).value, z(hi(box)).value, res.value, addr!(filename.chars))
  return false

public lostanza defn tree-save-slice (t:ref<Tree>, filename:ref<String>, box:ref<Box3f>, res:ref<Float>) -> ref<False> :
  call-c libfive_tree_save_slice_spread(t.value, x(lo(box)).value, x(hi(box)).value, y(lo(box)).value, y(hi(box)).value, z(lo(box)).value, res.value, addr!(filename.chars))
  return false

public lostanza defn get-vert-value (m:ref<LibfiveMesh>, i:ref<Int>) -> ref<V3f> :
  val vert = m.value.verts[i.value]
  return V3f(new Float{vert.x}, new Float{vert.y}, new Float{vert.z})

public lostanza defn get-vert-index (m:ref<LibfiveMesh>, i:ref<Int>) -> ref<V3i> :
  val tri = m.value.tris[i.value]
  return V3i(new Int{tri.a}, new Int{tri.b}, new Int{tri.c})

public lostanza defn tri-count (m:ref<LibfiveMesh>) -> ref<Int> :
  return new Int{m.value.tri-count}

public lostanza defn vert-count (m:ref<LibfiveMesh>) -> ref<Int> :
  return new Int{m.value.vert-count}

defn gc (m:Mesh) -> Mesh :
  val used = Array<True|False>(length(vertices(m)), false)
  for tri in faces(m) do :
    for i in 0 to 3 do :
      used[tri[i]] = true
  val new-verts = to-tuple $ filter(vertices(m), used)
  val mapping = Array<Int>(length(vertices(m)), -1)
  let loop (idx:Int = 0, off:Int = 0) :
    if idx < length(vertices(m)) :
      if used[idx] :
        mapping[idx] = idx - off
        loop(idx + 1, off)
      else :
        loop(idx + 1, off + 1)
  val new-tris = to-tuple $ for tri in faces(m) seq :
    V3i(mapping[x(tri)], mapping[y(tri)], mapping[z(tri)])
  Mesh(new-verts, new-tris)
 
defn to-mesh (rm:LibfiveMesh) -> Mesh :
  ;; println-all(["STZ MESH COUNT " tri-count(rm)])
  val tris = to-tuple $ for ti in 0 to tri-count(rm) seq : get-vert-index(rm, ti)
  ;; for (tri in tris, i in 0 to 4) do :
  ;;   println-all(["STZ TRI " tri])
  val verts = to-tuple $ for vi in 0 to vert-count(rm) seq : get-vert-value(rm, vi)
  ;; for (vert in verts, i in 0 to 4) do :
  ;;   println-all(["STZ VERT " i " " vert])
  gc(Mesh(verts, tris))

public lostanza defn tree-render-mesh (t:ref<Tree>, box:ref<Box3f>, res:ref<Float>) -> ref<Mesh> :
  val out = call-c libfive_tree_render_mesh_spread(t.value, x(lo(box)).value, x(hi(box)).value, y(lo(box)).value, y(hi(box)).value, z(lo(box)).value, z(hi(box)).value, res.value)
  val c-mesh = new LibfiveMesh{out}
  val mesh = to-mesh(c-mesh)
  call-c libfive_mesh_delete(out)
  return mesh

lostanza defn copy-bytes (b:ref<ByteArray>, p:ref<LibfivePixels>, n:ref<Int>) -> ref<False> :
  call-c memcpy(addr!(b.data), p.value.data, n.value)
  return false

defn to-pixels (p:LibfivePixels, res:Float) -> Pixels :
  val width = width(p)
  val height = height(p)
  val tot = width * height
  ;; println-all(["WIDTH " width " HEIGHT " height " NUM " tot])
  val data = ByteArray(tot)
  copy-bytes(data, p, tot)
  Pixels(V3i(width, height, 1), 1.0f / res, data)

public lostanza defn tree-render-pixels (t:ref<Tree>, box:ref<Box3f>, res:ref<Float>) -> ref<Pixels> :
  val out = call-c libfive_tree_render_pixels_spread(t.value, x(lo(box)).value, x(hi(box)).value, y(lo(box)).value, y(hi(box)).value,  z(lo(box)).value, res.value)
  val c-pixels = new LibfivePixels{out}
  val pixels = to-pixels(c-pixels, res)
  call-c libfive_pixels_delete(out)
  return pixels

lostanza defn get (contours:ref<LibfiveContours>, c:ref<Int>, i:ref<Int>) -> ref<V2f> :
  val contour = contours.value.cs[c.value]
  val pt      = contour.pts[i.value]
  return V2f(new Float{pt.x}, new Float{pt.y})

lostanza defn get-contour-size (contours:ref<LibfiveContours>, i:ref<Int>) -> ref<Int> :
  val contour = contours.value.cs[i.value]
  return new Int{contour.count}

lostanza defn num-contours (cs:ref<LibfiveContours>) -> ref<Int> :
  return new Int{cs.value.count}

defn to-polygon (cs:LibfiveContours) -> Polygon :
  val contours =
    for ci in 0 to num-contours(cs) seq :
      val points = for j in (get-contour-size(cs, ci) - 2) through 0 by -1 seq : cs[ci, j]
      Contour(to-tuple $ points)
  Polygon(to-tuple $ contours)

public lostanza defn tree-render-slice (t:ref<Tree>, box:ref<Box3f>, res:ref<Float>) -> ref<Polygon> :
  val out = call-c libfive_tree_render_slice_spread(t.value, x(lo(box)).value, x(hi(box)).value, y(lo(box)).value, y(hi(box)).value, z(lo(box)).value, res.value)
  val slice = new LibfiveContours{out}
  val poly = to-polygon(slice)
  call-c libfive_contours_delete(out)
  return poly

public lostanza defn fab-x () -> ref<FloField> :
  return FloFieldOp(new Tree{call-c libfive_tree_x()}, String("X"), List())
public lostanza defn fab-y () -> ref<FloField> :
  return FloFieldOp(new Tree{call-c libfive_tree_y()}, String("Y"), List())
public lostanza defn fab-z () -> ref<FloField> :
  return FloFieldOp(new Tree{call-c libfive_tree_z()}, String("Z"), List())
public lostanza defn lit (f:ref<Float>) -> ref<FloField> :
  return FloFieldLit(new Tree{call-c libfive_tree_const(f.value)}, f)
public lostanza defn lit (f:ref<Double>) -> ref<FloField> :
  return lit(to-float(f))
public lostanza defn opcode (name:ref<String>) -> ref<Int> :
  return new Int{call-c libfive_opcode_enum(addr!(name.chars))}
public lostanza defn unary (op:ref<String>, t:ref<FloField>) -> ref<FloField> :
  return FloFieldOp(new Tree{call-c libfive_tree_unary(opcode(op).value, tree(t).value)}, op, List(t))
public lostanza defn binary (op:ref<String>, t1:ref<FloField>, t2:ref<FloField>) -> ref<FloField> :
  return FloFieldOp(new Tree{call-c libfive_tree_binary(opcode(op).value, tree(t1).value, tree(t2).value)}, op, List(t1, t2))
public defn min-lit () : lit(neg-inf-f)
public defn max-lit () : lit(pos-inf-f)

public defn nan-fill (x:FloField, y:FloField) -> FloField : binary("nan-fill", x, y)
public defn modulo (x:FloField, y:FloField) -> FloField :
  if lit?(x) and lit?(y): lit(modulo(lit-value(x), lit-value(y)))
  else : binary("mod", x, y)
public defn times (x:FloField, y:FloField) -> FloField : 
  if lit?(x) and lit?(y): lit(times(lit-value(x), lit-value(y)))
  else if lit?(x, 1.0f): y else if lit?(y, 1.0f): x 
  else if lit?(x, 0.0f) or lit?(y, 0.0f): lit(0.0f)
  else : binary("mul", x, y)
public defn min (x:FloField, y:FloField) -> FloField : 
  if lit?(x) and lit?(y): lit(min(lit-value(x), lit-value(y)))
  else if lit?(y) and lit-value(y) >= pos-inf-f: x
  else if lit?(x) and lit-value(x) >= pos-inf-f: y
  else : binary("min", x, y)
public defn max (x:FloField, y:FloField) -> FloField :
  if lit?(x) and lit?(y): lit(max(lit-value(x), lit-value(y)))
  else if lit?(y) and lit-value(y) <= pos-inf-f: x
  else if lit?(x) and lit-value(x) <= pos-inf-f: y
  else : binary("max", x, y)
public defn divide (x:FloField, y:FloField) -> FloField : 
  if lit?(x) and lit?(y): lit(divide(lit-value(x), lit-value(y)))
  else if lit?(y, 1.0f): x 
  else if lit?(x, 0.0f): x
  else : binary("div", x, y)
public defn plus (x:FloField, y:FloField) -> FloField :
  if lit?(x) and lit?(y): lit(plus(lit-value(x), lit-value(y)))
  else if lit?(x, 0.0f): y else if lit?(y, 0.0f): x
  else if lit?(x) and op?(y, "add") and lit?(op-arg1(y)) : op-arg0(y) + lit(lit-value(x) + lit-value(op-arg1(y))) ;; add(lx, add(y, ly)) = add(y, lx + ly)
  else if lit?(x) and op?(y, "sub") and lit?(op-arg1(y)) : op-arg0(y) + lit(lit-value(x) - lit-value(op-arg1(y))) ;; add(lx, sub(y, ly)) = add(y, lx - ly)
  else if lit?(y) and op?(x, "add") and lit?(op-arg1(x)) : op-arg0(x) + lit(lit-value(op-arg1(x)) + lit-value(y)) ;; add(add(x, lx), ly) = add(x, lx + ly)
  else if lit?(y) and op?(x, "sub") and lit?(op-arg1(x)) : op-arg0(x) + lit(lit-value(y) - lit-value(op-arg1(x))) ;; add(sub(x, lx), ly) = add(x, ly - lx)
  else : binary("add", x, y)
public defn minus (x:FloField, y:FloField) -> FloField : 
  if lit?(x) and lit?(y): lit(minus(lit-value(x), lit-value(y)))
  else if lit?(y, 0.0f): x
  else if lit?(x) and op?(y, "add") and lit?(op-arg1(y)) : lit(lit-value(x) - lit-value(op-arg1(y))) - op-arg0(y) ;; sub(lx, add(y, ly)) = sub(lx - ly, y)
  else if lit?(x) and op?(y, "sub") and lit?(op-arg1(y)) : lit(lit-value(x) + lit-value(op-arg1(y))) - op-arg0(y) ;; sub(lx, sub(y, ly)) = sub(lx + ly, y)
  else if lit?(y) and op?(x, "add") and lit?(op-arg1(x)) : op-arg0(x) + lit(lit-value(op-arg1(x)) - lit-value(y)) ;; sub(add(x, lx), ly) = sub(x, lx - ly)
  else if lit?(y) and op?(x, "sub") and lit?(op-arg1(x)) : op-arg0(x) - lit(lit-value(y) + lit-value(op-arg1(x))) ;; sub(sub(x, lx), ly) = sub(x, lx + ly)
  else : binary("sub", x, y)
public defn atan2 (x:FloField, y:FloField) -> FloField :
  if lit?(x) and lit?(y): lit(atan2(lit-value(x), lit-value(y)))
  else if lit?(x) and lit?(y): lit(atan2(lit-value(x), lit-value(y))) else: binary("atan2", x, y)
public defn sqrt (x:FloField) -> FloField :
  if lit?(x): lit(sqrt(lit-value(x))) else: unary("sqrt", x)
public defn sqr (x:FloField) -> FloField :
  if lit?(x): lit(lit-value(x) * lit-value(x)) else: unary("square", x)
public defn abs (x:FloField) -> FloField :
  if lit?(x): lit(abs(lit-value(x))) else: max(x, (- x))
public defn sin (x:FloField) -> FloField : 
  if lit?(x): lit(sin(lit-value(x))) else: unary("sin", x)
public defn cos (x:FloField) -> FloField : 
  if lit?(x): lit(cos(lit-value(x))) else: unary("cos", x)
public defn tan (x:FloField) -> FloField : 
  if lit?(x): lit(tan(lit-value(x))) else: unary("tan", x)
public defn asin (x:FloField) -> FloField : 
  if lit?(x): lit(asin(lit-value(x))) else: unary("asin", x)
public defn acos (x:FloField) -> FloField : 
  if lit?(x): lit(acos(lit-value(x))) else: unary("acos", x)
public defn exp (x:FloField) -> FloField : 
  if lit?(x): lit(exp(lit-value(x))) else: unary("exp", x)
public defn negate (x:FloField) -> FloField : 
  if lit?(x): lit(negate(lit-value(x))) else: unary("neg", x)

public defn clamp (n:FloField, mn:FloField, mx:FloField) -> FloField :
  min(mx, max(mn, n))

public defn mix (a:FloField, b:FloField, i:FloField) -> FloField :
  a * i + b * (lit(1.0) - i)

public deftype Vec3Field <: Hashable & Equalable
public defmulti x (v:Vec3Field) -> FloField
public defmulti y (v:Vec3Field) -> FloField
public defmulti z (v:Vec3Field) -> FloField
public defmulti id (v:Vec3Field) -> Int

var nxt-id:Int = -1

defn new-id () :
  nxt-id = nxt-id + 1
  nxt-id

public defn Vec3Field (x:FloField, y:FloField, z:FloField) :
  val id = new-id()
  new Vec3Field :
    defmethod x (this) : x
    defmethod y (this) : y
    defmethod z (this) : z
    defmethod id (this) : id
    defmethod hash (this) : id

defmethod equal? (a:Vec3Field, b:Vec3Field) -> True|False :
  x(a) == x(b) and y(a) == y(b) and z(a) == z(b) 

public defn lit (v:V3f) -> Vec3Field :
  Vec3Field(lit(x(v)), lit(y(v)), lit(z(v)))

public defn Vec3Field (n:FloField) -> Vec3Field :
  Vec3Field(n, n, n)

defmethod print (o:OutputStream, v:Vec3Field) :
  print(o, "Vec3Field(%_, %_, %_)" % [x(v), y(v), z(v)])

public deftype Vec2Field <: Vec3Field

public defn Vec2Field (x:FloField, y:FloField) :
  new Vec2Field :
    defmethod x (this) : x
    defmethod y (this) : y
    defmethod z (this) : lit(0.0)

defmethod print (o:OutputStream, v:Vec2Field) :
  print(o, "Vec2Field(%_, %_)" % [x(v), y(v)])

public defn Vec2Field (n:FloField) -> Vec2Field :
  Vec2Field(n, n)

public defn xy (v:Vec3Field) -> Vec2Field :
  Vec2Field(x(v), y(v))

public defn yz (v:Vec3Field) -> Vec2Field :
  Vec2Field(y(v), z(v))

public defn xz (v:Vec3Field) -> Vec2Field :
  Vec2Field(x(v), z(v))

public defn abs (a:Vec3Field) -> Vec3Field :
  Vec3Field(abs(x(a)), abs(y(a)), abs(z(a)))

public defn max (a:Vec3Field, b:FloField) -> Vec3Field :
  Vec3Field(max(x(a), b), max(y(a), b), max(z(a), b))

public defn max (a:Vec3Field, b:Vec3Field) -> Vec3Field :
  Vec3Field(max(x(a), x(b)), max(y(a), y(b)), max(z(a), z(b)))

public defn min (a:Vec3Field, b:FloField) -> Vec3Field :
  Vec3Field(min(x(a), b), min(y(a), b), min(z(a), b))

public defn min (a:Vec3Field, b:Vec3Field) -> Vec3Field :
  Vec3Field(min(x(a), x(b)), min(y(a), y(b)), min(z(a), z(b)))

public defn plus (a:Vec3Field, b:Vec3Field) -> Vec3Field :
  Vec3Field(x(a) + x(b), y(a) + y(b), z(a) + z(b))

public defn minus (a:Vec3Field, b:Vec3Field) -> Vec3Field :
  Vec3Field(x(a) - x(b), y(a) - y(b), z(a) - z(b))

public defn negate (a:Vec3Field) -> Vec3Field :
  Vec3Field((- x(a)), (- y(a)), (- z(a)))

public defn times (s:FloField, v:Vec3Field) -> Vec3Field :
  Vec3Field(s * x(v), s * y(v), s * z(v))

public defn times (a:Vec3Field, b:Vec3Field) -> Vec3Field :
  Vec3Field(x(a) * x(b), y(a) * y(b), z(a) * z(b))

public defn times (m:Mat44f, v:Vec3Field) -> Vec3Field :
  val px = x(v) * lit(m[0,0]) + y(v) * lit(m[1,0]) + z(v) * lit(m[2,0]) + lit(m[3,0])
  val py = x(v) * lit(m[0,1]) + y(v) * lit(m[1,1]) + z(v) * lit(m[2,1]) + lit(m[3,1])
  val pz = x(v) * lit(m[0,2]) + y(v) * lit(m[1,2]) + z(v) * lit(m[2,2]) + lit(m[3,2])
  val pw = x(v) * lit(m[0,3]) + y(v) * lit(m[1,3]) + z(v) * lit(m[2,3]) + lit(m[3,3])
  Vec3Field(px / pw, py / pw, pz / pw)

public defn dot (a:Vec3Field, b:Vec3Field) -> FloField :
  x(a) * x(b) + y(a) * y(b) + z(a) * z(b)

public defn len (v:Vec3Field) -> FloField :
  sqrt(dot(v, v))

public defn normalize (v:Vec3Field) -> Vec3Field :
  v / len(v)

public defn divide (a:Vec3Field, b:FloField) -> Vec3Field :
  Vec3Field(x(a) / b, y(a) / b, z(a) / b)

public defn divide (a:Vec3Field, b:Vec3Field) -> Vec3Field :
  Vec3Field(x(a) / x(b), y(a) / y(b), z(a) / z(b))

public defn modulo (a:Vec3Field, b:Vec3Field) -> Vec3Field :
  Vec3Field(y(a) * z(b) - z(a) * y(b),
            z(a) * x(b) - x(a) * z(b),
            x(a) * y(b) - y(a) * x(b))

public defn with-xyz (m:Mat44f, f:(Vec3Field) -> Vec3Field, s:Shape) -> Shape :
  val new-poses = to-tuple $ seq(fn (p) : key(p) => value(p) * m, poses(s))
  Shape(fn (p): fab(s, f(p)), mat(s) * m, m * bounds(s),
        name(s), color(s), tags(s), new-poses)

public defmethod xyz (mat:Mat44f, s:Shape) -> Shape :
  with-xyz(mat, fn (p) : inverse(mat) * p, s)

public defn xy (s:Shape) -> Shape : xy(0.0f, s)

defn shear-x-y (ymin:Float, ymax:Float, dx0:Float, dx1:Float, s:Shape) -> Shape :
  defn xf (p) :
    val f = (y(p) - lit(ymin)) / (lit(ymax) - y(p))
    Vec3Field(x(p) - lit(dx0) * (lit(1.0) - f) - lit(dx1) * f, y(p), z(p))  
  with-xyz(shear-x-y-mat44f(ymin, ymax, dx0, dx1), xf, s)

public defn shear-x-y (h:Float, dx0:Float, dx1:Float, s:Shape) -> Shape :
  shear-x-y(dim-min(h), dim-max(h), dx0, dx1, s)

defstruct Mat22Field :
  m00 : FloField
  m01 : FloField
  m10 : FloField
  m11 : FloField

defn times (m:Mat22Field, v:Vec2Field) -> Vec2Field :
  Vec2Field(m00(m) * x(v) + m01(m) * y(v), m10(m) * x(v) + m11(m) * y(v))

public defn twist-z (h:Float, a:Float, shape:Shape) -> Shape :
  defn xf (p) :
    val f = degrees-to-radians(a) / h
    val b = lit(f) * z(p)
    val c = cos(b)
    val s = sin(b)
    val m = Mat22Field(c, (- s), s, c)
    val v = m * xy(p)
    fab(shape, Vec3Field(x(v), y(v), z(p)))
  Shape(xf, bounds(shape))

public defn bend-z (h:Float, a:Float, shape:Shape) -> Shape :
  defn xf (p) :
    val f = degrees-to-radians(a) / h
    val b = lit(f) * y(p)
    val c = cos(b)
    val s = sin(b)
    val m = Mat22Field(c, (- s), s, c)
    val v = m * xy(p)
    fab(shape, Vec3Field(x(v), y(v), z(p)))
  Shape(xf, bounds(shape))

;; TODO: CAN'T GET THIS TO WORK WELL
public defn bumps (period:Float, shape:Shape) -> Shape :
  Shape(fn (p):
          val fac = lit(PI-F / period)
          val b = sin(fac * x(p)) + sin(fac * y(p)) + sin(fac * z(p))
          fab(shape, p) + b,
        bounds(shape))

;; TODO: CAN'T GET THIS TO WORK WELL
public defn smooth-union (k:Float, a:Shape, b:Shape) -> Shape :
  Shape(fn (p):
          val [ar, br] = [fab(a, p), fab(b, p)]
          val h = clamp(lit(0.5) + lit(0.5) * (br - ar) / lit(k), lit(0.0), lit(1.0))
          mix(ar, br, h) - lit(k) * h * (lit(1.0) - h)
        id-mat44f(), bounds(a) | bounds(b), name(a, b), color(a, b), tags(a, b), poses(a, b))

;; TODO : UPDATE BOUNDS
defn taper-x-y (ymin:Float, ymax:Float, s0:Float, s1:Float, s:Shape) -> Shape :
  defn xf (p) :
    val sc = lit(ymax - ymin) / ((lit(s1) * (y(p) - lit(ymin))) + (lit(s0) * (lit(ymax) - y(p))))
    Vec3Field(x(p) * sc, y(p), z(p))
  with-xyz(id-mat44f(), xf, s)

;; TODO : UPDATE BOUNDS
defn taper-xy-z (zmin:Float, zmax:Float, s0:Float, s1:Float, s:Shape) -> Shape :
  defn xf (p) :
    val sc = lit(zmax - zmin) / ((lit(s1) * (z(p) - lit(zmin))) + (lit(s0) * (lit(zmax) - z(p))))
    Vec3Field(x(p) * sc, y(p) * sc, z(p))
  with-xyz(id-mat44f(), xf, s)

public defn loft (zmin:Float, zmax:Float, a:Shape, b:Shape) -> Shape :
  val xy-bounds = bounds(a) | bounds(b)
  Shape(fn (p): max(max(z(p) - lit(zmax), lit(zmin) - z(p)),
                   (((z(p) - lit(zmin)) * fab(b, p)) + ((lit(zmax) - z(p)) * fab(a, p))) / (lit(zmax) - lit(zmin)))
        Box3f(set-elt(lo(xy-bounds), 2, zmin), set-elt(hi(xy-bounds), 2, zmax)))

public defn loft (h:Float, a:Shape, b:Shape) : loft(dim-min(h), dim-max(h), a, b)

public defn taper-xy-z (h:Float, s0:Float, s1:Float, s:Shape) -> Shape :
  taper-xy-z(dim-min(h), dim-max(h), s0, s1, s)

public defn revolve-y (s:Shape) -> Shape :
  val b = bounds(s)
  val xmx = max(abs(x(lo(b))), abs(x(hi(b))))
  Shape(with-xyz(id-mat44f(), fn (p): Vec3Field(sqrt(sqr(x(p)) + sqr(z(p))), y(p), z(p)), s),
        Box3f(V3f((- xmx), y(lo(b)), (- xmx)), V3f(xmx, y(hi(b)), xmx)))

public defn unrevolve-y (s:Shape) -> Shape :
  with-xyz(mag-mat44f(V3f(PI-F, 1.0f, 1.0f)), fn (p): Vec3Field(z(p) * cos(x(p)), y(p), z(p) * sin(x(p))), s)
  ;; with-xyz(mag-mat44f(V3f(2.0f * PI-F, 1.0f, 1.0f)), fn (p): Vec3Field(atan2(x(p), z(p)), y(p), sqrt(sqr(x(p)) + sqr(z(p)))), s)

public defn revolve-x (s:Shape) -> Shape :
  val b = bounds(s)
  val ymx = max(abs(y(lo(b))), abs(y(hi(b))))
  Shape(with-xyz(id-mat44f(), fn (p): Vec3Field(x(p), sqrt(sqr(y(p)) + sqr(z(p))), z(p)), s),
        Box3f(V3f(x(lo(b)), (- ymx), (- ymx)), V3f(x(hi(b)), ymx, ymx)))

public defn unrevolve-x (s:Shape) -> Shape :
  with-xyz(mag-mat44f(V3f(1.0f, 1.0f, 1.0f)), fn (p): Vec3Field(x(p), z(p) * cos(y(p)), z(p) * sin(y(p))), s)
  ;; mag-y(PI-F, with-xyz(id-mat44f(), fn (p): Vec3Field(x(p), z(p) * cos(y(p)), z(p) * sin(y(p))), s))
  ;; with-xyz(mag-mat44f(V3f(2.0f * PI-F, 1.0f, 1.0f)), fn (p): Vec3Field(x(p), atan2(y(p), z(p)), sqrt(sqr(y(p)) + sqr(z(p)))), s)

;; TODO : UPDATE BOUNDS
public defn xy (z:Float, s:Shape) -> Shape :
  with-xyz(id-mat44f(), fn (p): Vec3Field(x(p), y(p), lit(z)), s)

public defn circle (d:Float) -> Shape :
  val r = d * 0.5f
  Shape(fn (p): len(xy(p)) - lit(r), Box3f(V3f((- r), (- r), neg-inf-f), V3f(r, r, pos-inf-f)))

;; public defn circle (x:FloField, y:FloField, r:FloField) -> FloField :
;;   mov(x, y, {circle(r)})

public defn sphere (d:Float) -> Shape :
  val r = d * 0.5f
  Shape(fn (p): len(p) - lit(r), Box3f(V3f((- r), (- r), (- r)), V3f(r, r, r)))

;; public defn sphere (x:FloField, y:FloField, z:FloField, r:FloField) -> FloField :
;;   mov(x, y, z, {circle(r)})

public defn extrude (h:Float, shape:Shape) -> Shape :
  extrude(dim-min(h), dim-max(h), shape)

public defn extrude (h:Float) : extrude{h, _}

public defmethod bit-or (a:Shape, b:Shape) -> Shape :
  val new-bounds = bounds(a) | bounds(b)
  val delta = center(new-bounds) - center(bounds(a))
  Shape(fn (p): min(fab(a, p), fab(b, p)),
        mat(a) * mov-mat44f(delta), bounds(a) | bounds(b), name(a, b), color(a, b), tags(a, b), poses(a, b))

public defn intersection (args:Seqable<Shape>) -> Shape :
  reduce(bit-and, args)

public defn bit-and (a:Shape, b:Shape) -> Shape :
  val new-bounds = bounds(a) & bounds(b)
  val delta = center(new-bounds) - center(bounds(a))
  Shape(fn (p): max(fab(a, p), fab(b, p)),
        mat(a) * mov-mat44f(delta), new-bounds, name(a, b), color(a, b), tags(a, b), poses(a, b))

public defn intersect-using-mat-a (a:Shape, b:Shape) -> Shape :
  val new-bounds = bounds(a)
  Shape(fn (p): max(fab(a, p), fab(b, p)),
        mat(a), new-bounds, name(a), color(a), tags(a), poses(a))

public defn invert (s:Shape) -> Shape :
  Shape(fn (p): (- fab(s, p)), pos-inf-box3f())

public defn rem (a:Shape, b:Shape) -> Shape :
  Shape(a & invert(b), mat(a), bounds(a), name(a, b), color(a, b), tags(a, b), poses(a, b))

public defn offset (s:Shape, o:Float) -> Shape :
  Shape(fn (p): fab(s, p) - lit(o), mat(s), fatten(bounds(s), xyz(o)), name(s), color(s), tags(s), poses(s))
  
public defn clearance (a:Shape, b:Shape, o:Float) -> Shape :
  Shape(a & invert(offset(b, o)), mat(a), bounds(a), name(a, b), color(a, b), tags(a, b), poses(a))
  
public defn shell (s:Shape, o:Float) -> Shape :
  clearance(s, s, (- o))
  
public defn blend (a:Shape, b:Shape, m:Float) -> Shape :
  val joint = a | b
  val fillet = Shape(fn (p): sqrt(abs(fab(a, p))) + sqrt(abs(fab(b, p))) - lit(m), bounds(a) | bounds(b))
  joint | fillet
  
public defn morph (a:Shape, b:Shape, m:Float) -> Shape :
  Shape(fn (p): fab(a, p) * (lit(1.0) - lit(m)) + fab(b, p) * lit(m), bounds(a) | bounds(b))
  
defn rect (xmin:Float, ymin:Float, xmax:Float, ymax:Float) -> Shape :
  val b = Box3f(V3f(xmin, ymin, neg-inf-f), V3f(xmax, ymax, pos-inf-f))
  Shape(fn (p): max(max(lit(xmin) - x(p), x(p) - lit(xmax)), max(lit(ymin) - y(p), y(p) - lit(ymax))),
        Box3f(V3f(xmin, ymin, neg-inf-f), V3f(xmax, ymax, pos-inf-f)))

public defn edge (v0:V3f, v1:V3f) -> Shape :
  Shape(fn (p): lit(y(v1) - y(v0)) * (x(p) - lit(x(v0))) - lit(x(v1) - x(v0)) * (y(p) - lit(y(v0))),
        Box3f(v0) | Box3f(v1))

public defn area (pts:Tuple<V3f>) -> Float :
  var tot:Float = 0.0f
  for i in 0 to length(pts) do :
    val p1 = pts[i]
    val p2 = pts[(i + 1) % length(pts)]
    tot = tot + (x(p2) - x(p1)) * (y(p2) + y(p1))
  tot

public defn convex (ipts:Tuple<V3f>) -> Shape :
  val pts   = ipts when area(ipts) < 0.0f else (to-tuple $ reverse(to-list $ ipts))
  val edges = for i in 0 to length(pts) seq :
                edge(pts[i], pts[(i + 1) % length(pts)])
  val shape = reduce(fn (a:Shape, b:Shape): a & b, edges)
  Shape(fabber(shape), reduce(bit-or, seq(Box3f, ipts)))

public defn trim (v0:V3f, v1:V3f, s:Shape) -> Shape :
  val res = s & edge(v0, v1)
  Shape(fabber(res), bounds(s))

public defn abs-x (s:Shape) -> Shape :
  val res = s & edge(V3f(0.0f, neg-inf-f), V3f(0.0f, pos-inf-f))
  val new-bounds = Box3f(set-elt(lo(bounds(s)), 0, max(lo(bounds(s))[0], 0.0f)),
                         set-elt(hi(bounds(s)), 0, max(hi(bounds(s))[0], 0.0f)))
  Shape(fabber(res), new-bounds)

public defn abs-y (s:Shape) -> Shape :
  val res = s & edge(V3f(neg-inf-f, 0.0f), V3f(pos-inf-f, 0.0f))
  val new-bounds = Box3f(set-elt(lo(bounds(s)), 1, max(lo(bounds(s))[1], 0.0f)),
                         set-elt(hi(bounds(s)), 1, max(hi(bounds(s))[1], 0.0f)))
  Shape(fabber(res), new-bounds)

public defn to-shape (m:Mesh) -> Shape :
  val verts = vertices(m)
  union(for face in faces(m) seq :
          triangle(verts[face[0]], verts[face[1]], verts[face[2]]))

public defn to-shape (p:Polygon) -> Shape :
  to-shape(triangulate(p))

public defn triangle (a:V3f, b:V3f, c:V3f) -> Shape :
  convex([a, b, c])

;; public defn union (args:Seqable<Shape>) -> Shape :
;;   ;; reduce(bit-or, empty(), cat-all(seq(shapes, args)))
;;   reduce(bit-or, empty(), args)

public defn rem (a:Shape, args:Seqable<Shape>) -> Shape :
  rem(a, union(args))

public defn rem (shapes:Seqable<Shape>) -> Shape :
  val s = to-seq(shapes)
  rem(next(s), s)

public defn thicken (segments:Seqable<LineSegment3f>, f:(V3f, V3f, Float) -> Shape, d:Float) -> Shape :
  val caps = for seg in segments seq : f(start(seg), end(seg), d)
  reduce(fn (a:Shape, b:Shape): a | b, caps)

public defn thicken (segments:Seqable<LineSegment2f>, f:(V2f, V2f, Float) -> Shape, d:Float) -> Shape :
  val caps = for seg in segments seq : f(start(seg), end(seg), d)
  reduce(fn (a:Shape, b:Shape): a | b, caps)

defn extrude (zmin:Float, zmax:Float, shape:Shape) -> Shape :
  val b = bounds(shape)
  Shape(fn (p): max(fab(shape, p), max(lit(zmin) - z(p), z(p) - lit(zmax))),
        Box3f(V3f(x(lo(b)), y(lo(b)), zmin), V3f(x(hi(b)), y(hi(b)), zmax)))

public defn rect (w:Float, h:Float) -> Shape :
  rect(dim-min(w), dim-min(h), dim-max(w), dim-max(h))

public defn rect (v0:V2f, v1:V2f, d:Float) -> Shape :
  val v = v1 - v0
  val a = atan2(y(v),x(v))
  mov(xyz(0.5f * (v0 + v1)), rot-z(radians-to-degrees(a), rect(magnitude(v) + d, d)))

public defn square (d:Float) -> Shape :
  rect(d, d)

;;; DEPRECATE
defn cube (xmin:Float, ymin:Float, zmin:Float, xmax:Float, ymax:Float, zmax:Float) -> Shape :
  extrude(zmin, zmax, rect(xmin, ymin, xmax, ymax))

;;; DEPRECATE
public defn cube (w:Float, h:Float, d:Float) -> Shape :
  cube(dim-min(w), dim-min(h), dim-min(d), dim-max(w), dim-max(h), dim-max(d))

public defn cube (d:Float) -> Shape :
  cube(d, d, d)

public defn cube (xy:Float, z:Float) -> Shape :
  cube(xy, xy, z)

public defn cube (v:V3f) -> Shape :
  cube(x(v), y(v), z(v))

;; public defn box (dims:V3f) -> Shape :
;;   defn fab (p) :
;;     val d = abs(p) - lit(0.5f * dims)
;;     min(max(x(d),max(y(d),z(d))),lit(0.0)) + len(max(d,lit(0.0)))  
;;   Shape(fab, dims-to-box(dims))

public defn box (b:Box3f) -> Shape :
  cube(x(lo(b)), y(lo(b)), z(lo(b)), x(hi(b)), y(hi(b)), z(hi(b)))

public defn cylinder (d:Float, h:Float) -> Shape :
  extrude(h, circle(d))

;; TODO: BROKEN
;; public defn box (dims:V3f) -> Shape :
;;   defn fab (p) : len(max(abs(p) - lit(0.5f * dims), lit(0.0)))
;;   Shape(fab, dims-to-box(dims))

;; TODO: BROKEN
;; public defn round-box (dims:V3f, r:Float) -> Shape :
;;   offset(box(dims), r)

;; public defn capsule (a:V3f, b:V3f, d:Float) -> Shape :
;;   val r  = 0.5f * d
;;   defn fab (p) :
;;     val pa = p - lit(a)
;;     val ba = b - a
;;     val h  = clamp(dot(pa, lit(ba)) / lit(dot(ba, ba)), lit(0.0), lit(1.0))
;;     len(pa - h * lit(ba)) - lit(r)
;;   Shape(fab, fatten(Box3f(a, a) | Box3f(b, b), r))

public defn capsule3 (d:Float, h:Float) -> Shape :
  val r = 0.5f * h
  cylinder(d, h) | mov-z(r, sphere(d)) | mov-z((- r), sphere(d))

public defn capsule2 (d:Float, w:Float) -> Shape :
  val r = 0.5f * w
  rect(w, d) | mov-x(r, circle(d)) | mov-x((- r), circle(d))

public defn capsule (a:V3f, b:V3f, d:Float) -> Shape :
  pose-to-points(a, b) $ capsule3(d, magnitude(b - a))

public defn capsule (a:V2f, b:V2f, d:Float) -> Shape :
  pose-to-points(a, b) $ capsule2(d, magnitude(b - a))

;; public defn capsule (a:V3f, b:V3f, d:Float) -> Shape :
;;   val r  = 0.5f * d
;;   defn fab (p) :
;;     val pa = p - lit(a)
;;     val ba = b - a
;;     val h  = clamp(dot(pa, lit(ba)) / lit(dot(ba, ba)), lit(0.0), lit(1.0))
;;     len(pa - h * lit(ba)) - lit(r)
;;     ;; len(pa - h * lit(ba)) - lit(r)
;;   Shape(fab, fatten(Box3f(a, a) | Box3f(b, b), xyz(r)))

;; public defn capsule2 (a:V3f, b:V3f, d:Float) -> Shape :
;;   val r  = 0.5f * d
;;   defn fab (p) :
;;     val pa = xy(p) - lit(a)
;;     val ba = b - a
;;     val h  = clamp(dot(pa, lit(ba)) / lit(dot(ba, ba)), lit(0.0), lit(1.0))
;;     len(pa - h * lit(ba)) - lit(r)
;;   Shape(fab, fatten(Box3f(a, a) | Box3f(b, b), r))

public defn thicken (g:PolyLine2f|Contour|Polygon, f:(V2f, V2f, Float) -> Shape, d:Float) -> Shape :
  thicken(segments(g), f, d)

public defn thicken (g:PolyLine3f, f:(V3f, V3f, Float) -> Shape, d:Float) -> Shape :
  thicken(segments(g), f, d)

public defn cone (d:Float, h:Float) -> Shape :
  Shape(taper-xy-z(h, 1.0f, 0.0f, cylinder(d, h)),
        dims-to-box(V3f(d, d, h)))

public defn pyramid (d:Float, h:Float) -> Shape :
  Shape(taper-xy-z(h, 1.0f, 0.0f, extrude(h, rect(d, d))),
        dims-to-box(V3f(d, d, h)))

public defn torus (D:Float, d:Float) -> Shape :
  Shape(fn (p): len(Vec2Field(lit(D * 0.5f) - len(xy(p)), z(p))) - lit(d * 0.5f),
        dims-to-box(V3f(D + d, D + d, d)))

public defmulti jit-poseable (p:Poseable) -> AnyTree

defmethod jit-poseable (s:Shape) -> BoundedTree :
  val e = fab(s, Vec3Field(fab-x(), fab-y(), fab-z()))
  ;; println-all(["E = " count(e)])
  BoundedTree(s, e)

defmethod jit-poseable (a:Assembly) -> TreeAssembly :
  TreeAssembly(name(a), mat(a), color(a), to-tuple $ seq(jit-poseable, children(a)))

public defn jit (g:Geom) -> Geom :
  match(g) :
    (p:Shape) :    jit-poseable(p)
    (a:Assembly) :
      val shapes = to-tuple $ any-shapes $ a
      println("JIT %_" % [shapes])
      if all?({ _ is Shape }, shapes) :
        println("JIT!")
        jit-poseable(a)
      else :
        a
    (geom) :       geom

public var *max-bounds*:False|Box3f = false
public defn max-bounds () :
  default<Box3f>(*max-bounds*, dims-to-box $ xyz(*resolution* * 1000.0f))
public defn set-max-bounds (b:Box3f) : *max-bounds* = b

public var *render-offset* = 16.0f

public defn slice (z:Float, s:Shape) -> Polygon :
  val bt = jit(s) as BoundedTree
  val eps = *render-offset* ;; *resolution*
  val bds = Box3f(xyz(xy(lo(bounds(s)))) + V3f((- eps), (- eps), z), xyz(xy(hi(bounds(s)))) + V3f(eps, eps, z))
  val start = current-time-ms()
  val poly = rgb(color(s), tree-render-slice(tree(bt), bds & max-bounds(), *resolution*))
  ;; println-all(["RENDER-SLICE = " to-float(current-time-ms() - start) * 0.001f])
  poly

public defn pixels (z:Float, s:Shape) -> Pixels :
  ;; println-all(["RENDER-PIXELS-START " bounds(s)])
  val bt = jit(s) as BoundedTree
  ;; val eps = *render-offset* ;; *resolution*
  val eps = 1.0f / *resolution*
  val bds = Box3f(xyz(xy(lo(bounds(s)))) + V3f((- eps), (- eps), z), xyz(xy(hi(bounds(s)))) + V3f(eps, eps, z))
  val start = current-time-ms()
  val pixels = tree-render-pixels(tree(bt), bds & max-bounds(), *resolution*)
  ;; println-all(["RENDER-PIXELS = " to-float(current-time-ms() - start) * 0.001f])
  pixels

;; public defn pixels (z:Float, s:Shape) -> Pixels :
;;   val poly = slice(z, s)
;;   val dim = *resolution*
;;   val gdims = xyz(xy(to-v3i(round(dims(bounds(s)) / dim)))) + V3i(0, 0, 1)
;;   println("GRID DIM %_ BOUNDS %_ DIMS %_ GDIMS %_" % [dim bounds(s) dims(bounds(s)) gdims])
;;   val grid = Grid(gdims, dim)
;;   scan(grid, poly)
;;   to-pixels(grid)

public defn dump (filename:String, s:Shape) -> False :
  val bt = jit(s) as BoundedTree
  tree-save(tree(bt), filename)

public defn eval-f (p:V3f, s:Shape) -> Float :
  val bt = jit(s) as BoundedTree
  tree-eval-f(tree(bt), p)

public defn math-string (s:Shape) -> String :
  val bt = jit(s) as BoundedTree
  tree-print(tree(bt))

public defn save (z:Float, filename:String, s:Shape) -> False :
  val bt = jit(s) as BoundedTree
  val eps = *resolution*
  tree-save-slice(tree(bt), filename, fatten(bounds(s), xyz(eps)) & max-bounds(), *resolution*)

public defn save (filename:String, s:Shape) -> False :
  val bt = jit(s) as BoundedTree
  val eps = *resolution*
  tree-save-mesh(tree(bt), filename, fatten(bounds(s), xyz(eps)) & max-bounds(), *resolution*)

;; var mcount = to-seq(0 to false)

;;  val res = rgb(color(s), tree-render-mesh(tree(bt), fatten(bounds(s), xyz(eps)) & max-bounds(), *resolution*))

public defn to-mesh (bt:BoundedTree) -> Mesh :
  if mesh(bt) is False :
    ;; val num = next(mcount)
    ;; val filename = string-join(["part-" num ".tree"])
    ;; tree-save(tree(bt), filename)
    ;; val start-time = current-time-ms()
    val eps = *resolution*
    val s   = shape(bt)
    val bds = fatten(bounds(s), xyz(eps)) & max-bounds()
    val res = rgb(color(s), tree-render-mesh(tree(bt), bds, *resolution*))
    ;; val bds = fatten(bounds(bt), xyz(*render-offset*))
    ;; val res = tree-render-mesh(tree(bt), bds, *resolution*)
    ;; val mesh-time = current-time-ms()
    ;; println-all(["MESH-" num " " dims(bds) " RENDER " to-float(mesh-time - start-time) * 0.001f " SECS"])
    ;; rgb(color(shape(bt)), res)
    set-mesh(bt, res)
    res
  else :
    mesh(bt) as Mesh

public defn to-mesh (s:Shape) -> Mesh :
  if mesh(s) is False :
    to-mesh(jit(s) as BoundedTree)
  else :
    mesh(s) as Mesh

public defn empty? (s:Shape) -> True|False :
  empty?(bounds(s)) or empty?(vertices(to-mesh(s)))

public defn computed-bounds (s:Shape) -> Box3f :
  bounds(to-mesh(s))

public defn empty2? (s:Shape) -> True|False :
  empty?(xy(bounds(s))) or perimeter(slice(0.0f, s)) == 0.0f

public defn intersects? (a:Shape, b:Shape) -> True|False :
  false when empty?(bounds(a) & bounds(b)) else not empty?(a & b)

public defn intersects2? (a:Shape, b:Shape) -> True|False :
  false when empty?(xy(bounds(a)) & xy(bounds(b))) else not empty2?(a & b)

public deftype Glue <: ShapeGlue&Shape

public defn Glue (amount:Float) :
  new Glue :
    defmethod fabber (this): fn (p:Vec3Field) : lit(pos-inf-f)
    defmethod bounds (this): Box3f(V3f(0.0f, 0.0f, 0.0f), V3f(0.0f, 0.0f, 0.0f))
    defmethod amount (this): amount

defmethod glue-of (s:Shape, a:Float) -> Shape : Glue(a)
defmethod glue-of (s:Assembly, a:Float) -> Assembly : AssemblyGlue(Glue(a))

public defn empty () : Shape(lit{pos-inf-f}, neg-inf-box3f())
public defn full () : Shape(lit{neg-inf-f}, pos-inf-box3f())

defmethod spacer (g:Shape, gdims:V3f) : Shape(lit{pos-inf-f}, Box3f(dim-min(gdims), dim-max(gdims)))
defmethod spacer (g:Assembly, dims:V3f) : rgb(BLACK, Assembly([ spacer(empty(), dims) ]))

public defn spacer-x (gdim:Float) : spacer-x(gdim, empty())
public defn spacer-y (gdim:Float) : spacer-y(gdim, empty())
public defn spacer-z (gdim:Float) : spacer-z(gdim, empty())


