defpackage shape :
  import core
  import math
  import collections
  import utils
  import geom

public deftype Poseable <: Geom
public defmulti bounds (p:Poseable) -> Box3f
public defmulti color (p:Poseable) -> V4f
public defmulti tags (p:Poseable) -> Tuple<Symbol>
public defmulti name (p:Poseable) -> False|Symbol
public defmulti set-name<?T> (p:?T&Poseable, name:Symbol) -> T
public defmulti points (p:Poseable) -> Tuple<V3f>
public defmulti xyz<?T> (mat:Mat44f, p:?T&Poseable) -> T
public defmulti rgb<?T> (c:V4f, p:?T&Poseable) -> T
public defmulti shapes (p:Poseable) -> Seqable<Shape>
public defmulti mov<?T> (v:V3f, p:?T&Poseable) -> T

public defn mov-x<?T> (dx:Float, p:?T&Poseable) -> T : mov(V3f(dx, 0.0f, 0.0f), p)
public defn mov-y<?T> (dy:Float, p:?T&Poseable) -> T : mov(V3f(0.0f, dy, 0.0f), p)
public defn mov-z<?T> (dz:Float, p:?T&Poseable) -> T : mov(V3f(0.0f, 0.0f, dz), p)
public defn mov (d:V3f)     : mov{d, _}
public defn mov-x (d:Float) : mov-x{d, _}
public defn mov-y (d:Float) : mov-y{d, _}
public defn mov-z (d:Float) : mov-z{d, _}

public defn shapes (s:Seqable<Shape>) : s

public defn rgb (c:V4f) : rgb{c, _}

;;; ASSEMBLIES

public deftype Assembly <: Poseable
public defmulti children (a:Assembly) -> Seqable<Poseable>
public defmulti mat (l:Assembly) -> Mat44f

public defn Assembly (mat:Mat44f, name:False|Symbol, color:V4f, poseables:Seqable<Poseable>) -> Assembly :
  val children = to-tuple $ poseables
  if length(children) == 0 : fatal("EMPTY CHILDREN")
  new Assembly :
    defmethod children (this) : children
    defmethod name (this) : name
    defmethod tags (this) : to-tuple $ unique $ cat-all $ seq(tags, children)
    defmethod bounds (this) : mat * reduce(bit-or, seq(bounds, children))
    defmethod mat (this) : mat
    defmethod color (this) : color
    defmethod shapes (this) : seq(rgb{color, _}, seq(xyz{mat, _}, cat-all $ seq(shapes, children)))
    defmethod points (this) : to-tuple $ cat-all $ seq(points, children)

public defn Assembly (mat:Mat44f, poseables:Seqable<Poseable>) -> Assembly :
  Assembly(mat, false, V4f(0.0f, 0.0f, 0.0f, 0.0f), poseables)
  
public defn Assembly (poseables:Seqable<Poseable>) -> Assembly :
  Assembly(id-mat44f(), poseables)
  
public defn Assembly (color:V4f, poseables:Seqable<Poseable>) -> Assembly :
  Assembly(id-mat44f(), false, color, poseables)

defmethod print (s:OutputStream, a:Assembly) :
  print(s, "Assembly(%_ %,)" % [name(a), children(a)])

public defmethod xyz (xf:Mat44f, a:Assembly) -> Assembly :
  Assembly(mat(a) * xf, name(a), color(a), children(a))

public defmethod rgb (c:V4f, a:Assembly) -> Assembly :
  Assembly(mat(a), name(a), c, children(a))

public defmethod set-name (a:Assembly, name:Symbol) -> Assembly :
  Assembly(mat(a), name, color(a), children(a))

;;; ANYSHAPE

public deftype AnyShape <: Poseable
public defmulti clone<?T> (s:?T&AnyShape, name:False|Symbol, points:Tuple<V3f>, tags:Tuple<Symbol>) -> T

public defn add-points<?T> (s:?T&AnyShape, points:Tuple<V3f>) -> T :
  clone(s, name(s), points, tags(s))
public defn add-tags<?T> (s:?T&AnyShape, tags:Tuple<Symbol>) -> T :
  clone(s, name(s), points(s), tags)

public defmethod set-name (s:AnyShape, name:Symbol) :
  clone(s, name, points(s), tags(s))

public defn add-min-x-point<?T> (s:?T&AnyShape) -> T :
  add-points(s, [V3f(x(lo(bounds(s))), 0.0f, 0.0f)])
public defn add-max-x-point<?T> (s:?T&AnyShape) -> T :
  add-points(s, [V3f(x(hi(bounds(s))), 0.0f, 0.0f)])
public defn add-min-y-point<?T> (s:?T&AnyShape) -> T :
  add-points(s, [V3f(0.0f, y(lo(bounds(s))), 0.0f)])
public defn add-max-y-point<?T> (s:?T&AnyShape) -> T :
  add-points(s, [V3f(0.0f, y(hi(bounds(s))), 0.0f)])
public defn add-min-z-point<?T> (s:?T&AnyShape) -> T :
  add-points(s, [V3f(0.0f, 0.0f, z(lo(bounds(s))))])
public defn add-max-z-point<?T> (s:?T&AnyShape) -> T :
  add-points(s, [V3f(0.0f, 0.0f, z(hi(bounds(s))))])

public defn degrees-to-radians (d:Float) -> Float :
  d * to-float(PI-F) / 180.0f

public defn radians-to-degrees (a:Float) -> Float :
  a * 180.0f / to-float(PI-F)

public defn rot-x<?T> (d:Float, s:?T&Poseable) -> T :
  xyz(rot-mat44f(V3f(degrees-to-radians(d), 0.0f, 0.0f)), s)

public defn rot-y<?T> (d:Float, s:?T&Poseable) -> T :
  xyz(rot-mat44f(V3f(0.0f, degrees-to-radians(d), 0.0f)), s)

public defn rot-z<?T> (d:Float, s:?T&Poseable) -> T :
  xyz(rot-mat44f(V3f(0.0f, 0.0f, degrees-to-radians(d))), s)

public defn rot-x (d:Float) : rot-x{d, _}
public defn rot-y (d:Float) : rot-y{d, _}
public defn rot-z (d:Float) : rot-z{d, _}

public defn reflect-x<?T> (s:?T&Poseable) -> T : xyz(mag-mat44f(V3f(-1.0f, 1.0f, 1.0f)), s)
public defn reflect-y<?T> (s:?T&Poseable) -> T : xyz(mag-mat44f(V3f( 1.0f,-1.0f, 1.0f)), s)
public defn reflect-z<?T> (s:?T&Poseable) -> T : xyz(mag-mat44f(V3f( 1.0f, 1.0f,-1.0f)), s)
public defn reflect-xy<?T> (s:?T&Poseable) -> T : xyz(reflect-xy-mat44f(), s)
public defn reflect-xz<?T> (s:?T&Poseable) -> T : xyz(reflect-xz-mat44f(), s)
public defn reflect-yz<?T> (s:?T&Poseable) -> T : xyz(reflect-yz-mat44f(), s)
public defn mag<?T> (fac:Float, s:?T&Poseable) -> T : xyz(mag-mat44f(fac), s)
public defn mag1<?T> (sa:Float, s:?T&Poseable) -> T : xyz(mag-mat44f(sa), s)
public defn mag<?T> (fac:V3f, s:?T&Poseable) -> T : xyz(mag-mat44f(fac), s)
public defn mag-x<?T> (sx:Float, s:?T&Poseable) -> T : xyz(mag-mat44f(V3f(sx, 1.0f, 1.0f)), s)
public defn mag-y<?T> (sy:Float, s:?T&Poseable) -> T : xyz(mag-mat44f(V3f(1.0f, sy, 1.0f)), s)
public defn mag-z<?T> (sz:Float, s:?T&Poseable) -> T : xyz(mag-mat44f(V3f(1.0f, 1.0f, sz)), s)
public defn mag   (s:V3f)    : mag{s, _}
public defn mag1  (s:Float)  : mag-x{s, _}
public defn mag-x (sx:Float) : mag-x{sx, _}
public defn mag-y (sy:Float) : mag-y{sy, _}
public defn mag-z (sz:Float) : mag-z{sz, _}

public defn name (a:AnyShape, b:AnyShape) :
  name(a) when name(a) is Symbol else name(b)

public defn tags (a:AnyShape, b:AnyShape) :
  to-tuple $ unique $ cat(tags(a), tags(b))

public defn points (a:AnyShape, b:AnyShape) :
  to-tuple $ unique $ cat(points(a), points(b))

public defn dim-min (d:Float) -> Float : d * -0.5f
public defn dim-max (d:Float) -> Float : d *  0.5f

public defn dim-min (dim:V3f) -> V3f : V3f(dim-min(x(dim)), dim-min(y(dim)), dim-min(z(dim)))
public defn dim-max (dim:V3f) -> V3f : V3f(dim-max(x(dim)), dim-max(y(dim)), dim-max(z(dim)))

;;; SHAPE

public deftype Shape <: AnyShape

;;;; SPACE

public defmulti spacer<?T> (g:?T&Poseable, dims:V3f) -> T

;; public defn space-x (gdim:Float, shape:AnyShape) : mag1(gdim / x(dims(bounds(shape))), shape)
;; public defn space-y (gdim:Float, shape:AnyShape) : mag1(gdim / y(dims(bounds(shape))), shape)
;; public defn space-z (gdim:Float, shape:AnyShape) : mag1(gdim / z(dims(bounds(shape))), shape)

public defn spacer-x<?T> (gdim:Float, g:?T&Poseable) : spacer(g, V3f(gdim, 0.0f, 0.0f))
public defn spacer-y<?T> (gdim:Float, g:?T&Poseable) : spacer(g, V3f(0.0f, gdim, 0.0f))
public defn spacer-z<?T> (gdim:Float, g:?T&Poseable) : spacer(g, V3f(0.0f, 0.0f, gdim))

public defn space<?T> (gdims:V3f, shape:?T&AnyShape) -> T :
  val gratio = gdims / dims(bounds(shape))
  val fac    = min(gratio)
  mag1(fac, shape)

public defn stack-idx-using<?T> (ishapes:Seqable<?T&Poseable>, iboundz:Seqable<Box3f>, idx:Int, dir:Float) -> Seq<T> :
  val [shapes, boundz] = [to-tuple(ishapes), to-tuple(iboundz)]
  val tot = reduce(plus, for bounds in boundz seq : dims(bounds)[idx])
  var tot-fac = 0.0f
  val res =
    to-tuple $ generate<T&Poseable> :
      for (child in shapes, bounds in boundz) do :
        val now-fac = dims(bounds)[idx] / tot
        val ctr     = center(bounds)[idx]
        val amount  = dir * (tot / 2.0f - (tot-fac + now-fac / 2.0f) * tot) - ctr
        val del     = amount * V3f-unit(idx)
        ;; println("STACKING %_ DEL %_ TOT %_ BOUNDS %_ DIMS %_ VOLUME %_" % [child del tot bounds dims(bounds) volume(dims(bounds))])
        yield(mov(del, child))
        tot-fac = tot-fac + now-fac
  ;; for r in res do :
  ;;   println("STACKED %_ BOUNDS %_ DIMS %_ VOLUME %_" % [r bounds(r) dims(bounds(r)) volume(dims(bounds(r)))])
  ;; val bdz = to-tuple $ seq({ volume(dims(bounds(_))) }, res)
  val rres = to-tuple $ filter({ volume(dims(bounds(_))) > 0.0f }, res)
  ;; println("STACKING RRES %_" % [rres])
  filter({ volume(dims(bounds(_))) > 0.0f }, res)

public defn stack-idx<?T> (ishapes:Seqable<?T&Poseable>, idx:Int, dir:Float) -> Seq<T> :
  val shapes = to-tuple $ ishapes
  stack-idx-using(shapes, seq(bounds, shapes), idx, dir)

public defn stack-x<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  stack-idx(shapes, 0,  1.0f)

public defn stack-y<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  stack-idx(shapes, 1,  1.0f)

public defn stack-z<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  stack-idx(shapes, 2,  1.0f)

public deftype AnyGlue <: Poseable
public defmulti amount (g:AnyGlue) -> Float

public defn glue-amount<?T> (shape:?T&Poseable) -> Float :
  match(shape) :
    (g:AnyGlue) : amount(g)
    (s)         : 0.0f


public deftype AssemblyGlue <: AnyGlue & Assembly
public deftype ShapeGlue <: AnyGlue & AnyShape
defmulti glue (g:AssemblyGlue) -> ShapeGlue

public defn AssemblyGlue (glue:ShapeGlue) :
  new AssemblyGlue :
    defmethod glue (this) : glue
    defmethod color (this): BLACK
    defmethod bounds (this) : bounds(glue)
    defmethod amount (this) : amount(glue)

public defmulti glue-of<?T> (s:?T&Poseable, a:Float) -> T

public defn glue-when<?T> (first?:True|False, shapes:Seqable<?T&Poseable>) -> Seq<T> :
  generate<T> :
    for (shape in shapes, i in 0 to false) do :
      if first? or i > 0:
        yield(glue-of(shape, 1.0f))
      yield(shape)

public defn glue-even<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  glue-when(true, shapes)

public defn glue-odd<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  glue-when(false, shapes)

public defn glue<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  glue-odd(shapes)

public defn assign-glue-idx<?T> (ishapes:Seqable<?T&Poseable>, target:Float, idx:Int) -> Seq<T> :
  val shapes = to-tuple(ishapes)
  val tot = reduce(plus, for shape in shapes seq : dims(bounds(shape))[idx])
  val glue-tot = reduce(plus, for shape in shapes seq : glue-amount(shape))
  val gap-tot = (target - tot)
  for shape in shapes seq :
    match(shape) :
      (g:AnyGlue&T) :
        val s = (amount(g) / glue-tot) * gap-tot * V3f-unit(idx)
        spacer(shape, s)
      (s)           : s

;; public defn interleave<?T> (a:Seqable<?T&Poseable>, b:Seqable<?T&Poseable>) -> Seq<T> :
;;   generate<T> :
;;     val [sa, sb] = [to-seq(a), to-seq(b)]
;;     let loop (a?:True|False = true) :
;;       if not empty?(sa) and not empty?(sa):
;;         yield(next(sa) when a? else next(sb))
;;         loop(not a?)

public defn stack-idx<?T> (d:Float, idx:Int, shapes:Seqable<?T&Poseable>) -> Seq<T> :
  stack-idx(assign-glue-idx(shapes, d, idx), idx, 1.0f)

public defn stack-x<?T> (w:Float, shapes:Seqable<?T&Poseable>) -> Seq<T> :
  stack-x(assign-glue-idx(shapes, w, 0))
public defn stack-y<?T> (h:Float, shapes:Seqable<?T&Poseable>) -> Seq<T> :
  stack-y(assign-glue-idx(shapes, h, 1))
public defn stack-z<?T> (d:Float, shapes:Seqable<?T&Poseable>) -> Seq<T> :
  stack-z(assign-glue-idx(shapes, d, 2))
public defn stack-x (w:Float) : stack-x{w, _}
public defn stack-y (h:Float) : stack-y{h, _}
public defn stack-z (d:Float) : stack-z{d, _}

public defn space-idx<?T> (iseps:Seqable<Float>, idx:Int, ishapes:Seqable<?T&Poseable>) -> Seq<T> :
  val shapes = to-tuple $ ishapes
  val seps = to-tuple $ for (sep in iseps, i in 0 to (length(shapes) - 1)) seq : sep
  val tot = reduce(plus, 0.0f, seps)
  val start = -0.5f * tot
  val offs = generate<Float> :
    let loop (off = start, i = 0) :
      yield(off)
      if i < length(seps) : loop(off + seps[i], i + 1)
  for (shape in shapes, off in offs) seq :
    mov(off * V3f-unit(idx), shape)

public defn space-x<?T> (seps:Seqable<Float>, shapes:Seqable<?T&Poseable>) : space-idx(seps, 0, shapes)
public defn space-y<?T> (seps:Seqable<Float>, shapes:Seqable<?T&Poseable>) : space-idx(seps, 1, shapes)
public defn space-z<?T> (seps:Seqable<Float>, shapes:Seqable<?T&Poseable>) : space-idx(seps, 2, shapes)

public defn space-idx<?T> (sep:Float, idx:Int, shapes:Seqable<?T&Poseable>) -> Seq<T> :
  space-idx(repeatedly({ sep }), idx, shapes)

public defn space-x<?T> (sep:Float, shapes:Seqable<?T&Poseable>) : space-idx(sep, 0, shapes)
public defn space-y<?T> (sep:Float, shapes:Seqable<?T&Poseable>) : space-idx(sep, 1, shapes)
public defn space-z<?T> (sep:Float, shapes:Seqable<?T&Poseable>) : space-idx(sep, 2, shapes)

public defn space-idx (sep:Float, idx:Int) : space-idx{repeatedly({ sep }), idx, _}

public defn space-x (sep:Float) : space-idx(sep, 0)
public defn space-y (sep:Float) : space-idx(sep, 1)
public defn space-z (sep:Float) : space-idx(sep, 2)

defn align-it<?T> (ishapes:Seqable<?T&Poseable>, value:(Box3f) -> Float, mov:(Float, T) -> T) -> Seq<T> :
  val shapes = to-tuple(ishapes)
  val target = reduce(union, seq(bounds, shapes))
  ;; val target = bounds(shapes[0])
  for (child in shapes) seq :
    mov(value(target) - value(bounds(child)), child)

public defn attach<?T> (src:?T&Poseable, spos:V3f, dst:?T&Poseable, dpos:V3f) -> Seqable<T> :
  [mov(dpos - spos, src), dst]

public defn attach<?T> (src:?T&Poseable, si:Int, dst:?T&Poseable, di:Int) -> Seqable<T> :
  attach(src, points(src)[si], dst, points(dst)[di])

public defn align-min-x<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  align-it(shapes, { x(lo(_)) }, mov-x)

public defn align-max-x<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  align-it(shapes, { x(hi(_)) }, mov-x)

public defn align-min-y<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  align-it(shapes, { y(lo(_)) }, mov-y)

public defn align-max-y<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  align-it(shapes, { y(hi(_)) }, mov-y)

public defn align-min-z<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  align-it(shapes, { z(lo(_)) }, mov-z)

public defn align-max-z<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  align-it(shapes, { z(hi(_)) }, mov-z)


