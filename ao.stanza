defpackage ao :
  import core
  import math
  import collections
  import utils
  import glu
  import geom
  import font
  import grid
  import nester

lostanza deftype ao_interval :
  lower : float
  upper : float

lostanza deftype ao_region2 :
  X : ao_interval
  Y : ao_interval

lostanza deftype ao_region3 :
  X : ao_interval
  Y : ao_interval
  Z : ao_interval

lostanza deftype ao_vec2 :
  x : float
  y : float

lostanza deftype ao_vec3 :
  x : float
  y : float
  z : float

lostanza deftype ao_vec4 :
  x : float
  y : float
  z : float
  w : float

lostanza deftype ao_tri :
  a : int
  b : int
  c : int

lostanza deftype ao_contour :
  pts : ptr<ao_vec2>
  count : int

lostanza deftype ao_contours :
  cs : ptr<ao_contour>
  count : int

lostanza deftype AoContours :
  value : ptr<ao_contours>

lostanza deftype ao_mesh :
  verts : ptr<ao_vec3>
  tris : ptr<ao_tri>
  tri-count : int
  vert-count : int

lostanza deftype AoMesh :
  value : ptr<ao_mesh>

lostanza deftype ao_pixels :
  data : ptr<byte>
  width : int
  height : int

lostanza deftype AoPixels :
  value : ptr<ao_pixels>

lostanza defn width (p:ref<AoPixels>) -> ref<Int> :
  return new Int{p.value.width}

lostanza defn height (p:ref<AoPixels>) -> ref<Int> :
  return new Int{p.value.height}

extern memcpy: (ptr<byte>, ptr<byte>, int) -> ptr<byte>

extern ao_tree_x: () -> ptr<?>
extern ao_tree_y: () -> ptr<?>
extern ao_tree_z: () -> ptr<?>
extern ao_tree_const: (float) -> ptr<?>
extern ao_tree_unary: (int, ptr<?>) -> ptr<?>
extern ao_tree_binary: (int, ptr<?>, ptr<?>) -> ptr<?>
extern ao_opcode_enum: (ptr<?>) -> int
extern ao_tree_delete: (ptr<?>) -> int
extern ao_tree_save: (ptr<?>, ptr<byte>) -> int
extern ao_tree_save_mesh_spread: (ptr<?>, float, float, float, float, float, float, float, ptr<byte>) -> int
extern ao_tree_save_slice_spread: (ptr<?>, float, float, float, float, float, float, ptr<byte>) -> int
extern ao_tree_render_mesh_spread: (ptr<?>, float, float, float, float, float, float, float) -> ptr<ao_mesh>
extern ao_tree_render_slice_spread: (ptr<?>, float, float, float, float, float, float) -> ptr<ao_contours>
extern ao_tree_render_pixels_spread: (ptr<?>, float, float, float, float, float, float) -> ptr<ao_pixels>
extern ao_contours_delete: (ptr<ao_contours>) -> int
extern ao_mesh_delete: (ptr<ao_mesh>) -> int
extern ao_pixels_delete: (ptr<ao_pixels>) -> int
extern printf: (ptr<?>, ? ...) -> int
extern free: (ptr<?>) -> int

public lostanza deftype Tree <: Geom :
  value: ptr<?>

defmethod print (o:OutputStream, t:Tree) :
  print-all(o, ["Tree()"])

public deftype FloField <: Equalable
public defmulti tree (f:FloField) -> Tree
public defmulti count (f:FloField) -> Int

public defstruct FloFieldLit <: FloField :
  tree: Tree with: (as-method => true)
  value: Float

defn lit? (f:FloField) -> True|False :
  match(f):
  (l:FloFieldLit) : true
  (o:FloFieldOp) : false

defn lit? (f:FloField, v:Float) -> True|False :
  match(f):
  (l:FloFieldLit) : value(l) == v
  (o:FloFieldOp) : false

defn op? (f:FloField, name:String) -> True|False :
  match(f):
  (l:FloFieldLit) : false
  (o:FloFieldOp) : name == op(o)

defn op-args (f:FloField) -> List<FloField> :
  match(f):
  (l:FloFieldLit) : List()
  (o:FloFieldOp) : args(o)

defn op-arg0 (f:FloField) -> FloField : op-args(f)[0]
defn op-arg1 (f:FloField) -> FloField : op-args(f)[1]

defn lit-value (f:FloField) -> Float :
  match(f):
  (l:FloFieldLit) : value(l)
  (o:FloFieldOp) : 0.0f

defmethod print (s:OutputStream, f:FloFieldLit) :
  print(s, "LIT(%_)" % [value(f)])

defmethod equal? (a:FloFieldLit, b:FloFieldLit) -> True|False :
  value(a) == value(b)

defmethod count (a:FloFieldLit) -> Int :
  1

public defstruct FloFieldOp <: FloField :
  tree: Tree with: (as-method => true)
  op: String
  args: List<FloField>

defmethod print (s:OutputStream, f:FloFieldOp) :
  print(s, "%_(%,)" % [op(f), args(f)])

defmethod equal? (a:FloFieldOp, b:FloFieldOp) -> True|False :
  op(a) == op(b) and all?(equal?, args(a), args(b))

defmethod count (f:FloFieldOp) -> Int :
  1 + reduce(plus, 0, seq(count, args(f)))

public deftype Poseable <: Geom
public defmulti bounds (p:Poseable) -> Box
public defmulti color (p:Poseable) -> V4f
public defmulti tags (p:Poseable) -> Tuple<Symbol>
public defmulti points (p:Poseable) -> Tuple<V3f>
public defmulti xyz<?T> (mat:Mat44, p:?T&Poseable) -> T
public defmulti rgb<?T> (c:V4f, p:?T&Poseable) -> T
public defmulti shapes (p:Poseable) -> Seqable<Shape>

public defn mov-x<?T> (dx:Float, p:?T&Poseable) -> T : mov(V3f(dx, 0.0f, 0.0f), p)
public defn mov-y<?T> (dy:Float, p:?T&Poseable) -> T : mov(V3f(0.0f, dy, 0.0f), p)
public defn mov-z<?T> (dz:Float, p:?T&Poseable) -> T : mov(V3f(0.0f, 0.0f, dz), p)
public defn mov (d:V3f)     : mov{d, _}
public defn mov-x (d:Float) : mov-x{d, _}
public defn mov-y (d:Float) : mov-y{d, _}
public defn mov-z (d:Float) : mov-z{d, _}

public defn shapes (s:Seqable<Shape>) : s

;;; ASSEMBLIES

public deftype Assembly <: Poseable
public defmulti children (a:Assembly) -> Seqable<Poseable>
public defmulti mat (l:Assembly) -> Mat44

public defn Assembly (mat:Mat44, color:V4f, poseables:Seqable<Poseable>) -> Assembly :
  val children = to-tuple $ poseables
  new Assembly :
    defmethod children (this) : children
    defmethod tags (this) : to-tuple $ unique $ cat-all $ seq(tags, children)
    defmethod bounds (this) : mat * reduce(bit-or, seq(bounds, children))
    defmethod mat (this) : mat
    defmethod color (this) : color
    defmethod shapes (this) : seq(rgb{color, _}, seq(xyz{mat, _}, cat-all $ seq(shapes, children)))
    defmethod points (this) : to-tuple $ cat-all $ seq(points, children)

public defn Assembly (mat:Mat44, poseables:Seqable<Poseable>) -> Assembly :
  Assembly(mat, V4f(0.0f, 0.0f, 0.0f, 0.0f), poseables)
  
public defn Assembly (poseables:Seqable<Poseable>) -> Assembly :
  Assembly(id-mat44(), poseables)
  
public defn Assembly (color:V4f, poseables:Seqable<Poseable>) -> Assembly :
  Assembly(id-mat44(), color, poseables)

defmethod print (s:OutputStream, a:Assembly) :
  print(s, "Assembly(%,)" % [children(a)])

public defmethod xyz (xf:Mat44, a:Assembly) -> Assembly :
  Assembly(mat(a) * xf, color(a), children(a))

public defmethod rgb (c:V4f, a:Assembly) -> Assembly :
  Assembly(mat(a), color(a), children(a))

public deftype AnyTree <: Geom

public defstruct BoundedTree <: AnyTree :
  shape: Shape
  field: FloField

public defn bounds (t:BoundedTree) : bounds(shape(t))
public defn tree (t:BoundedTree) : tree(field(t))
public defn mesh (t:BoundedTree) : mesh(shape(t))
public defn set-mesh (t:BoundedTree, m:Mesh) : set-mesh(shape(t), m)

public defstruct TreeAssembly <: AnyTree :
  mat   : Mat44
  color : V4f
  trees : Tuple<AnyTree>

;;; SHAPE

public deftype Shape <: Poseable
public defmulti fabber (s:Shape) -> ((Vec3Field) -> FloField)
public defmulti cache (s:Shape) -> HashTable<Vec3Field,FloField>
public defmulti mesh (s:Shape) -> False|Mesh
public defmulti set-mesh (s:Shape, m:Mesh) -> False

public defn Shape (fabber:(Vec3Field) -> FloField, bounds:Box, tags:Tuple<Symbol>, points:Tuple<V3f>) :
  val cache = HashTable<Vec3Field,FloField>()
  var mesh:False|Mesh = false
  new Shape :
    defmethod fabber (this) : fabber
    defmethod bounds (this) : bounds
    defmethod points (this) : points
    defmethod cache (this) : cache
    defmethod tags (this) : tags
    defmethod shapes (this) : [ this ]
    defmethod mesh (this) : mesh
    defmethod set-mesh (this, m:Mesh) : mesh = m

public defn Shape (fabber:(Vec3Field) -> FloField, bounds:Box) :
  Shape(fabber, bounds, [], [])

public defn add-points (s:Shape, points:Tuple<V3f>) :
  Shape(fabber(s), bounds(s), tags(s), points)

public defn add-tags (s:Shape, tags:Tuple<Symbol>) :
  Shape(fabber(s), bounds(s), tags, points(s))

public defn add-min-x-point (s:Shape) :
  add-points(s, [V3f(x(lo(bounds(s))), 0.0f, 0.0f)])
public defn add-max-x-point (s:Shape) :
  add-points(s, [V3f(x(hi(bounds(s))), 0.0f, 0.0f)])
public defn add-min-y-point (s:Shape) :
  add-points(s, [V3f(0.0f, y(lo(bounds(s))), 0.0f)])
public defn add-max-y-point (s:Shape) :
  add-points(s, [V3f(0.0f, y(hi(bounds(s))), 0.0f)])
public defn add-min-z-point (s:Shape) :
  add-points(s, [V3f(0.0f, 0.0f, z(lo(bounds(s))))])
public defn add-max-z-point (s:Shape) :
  add-points(s, [V3f(0.0f, 0.0f, z(hi(bounds(s))))])

defmethod print (s:OutputStream, o:Shape) :
  print-all(s, ["Shape(" bounds(o) ")"])

defn fab (s:Shape, p:Vec3Field) -> FloField :
  fabber(s)(p)
  ;; if key?(cache(s), p) :
  ;;   cache(s)[p]
  ;; else :
  ;;   val f = fabber(s)(p)
  ;;   cache(s)[p] = f
  ;;   ;; if length(cache(s)) > 1 :
  ;;   ;;   println-all(["MISS " to-tuple $ keys(cache(s))])
  ;;   f

public defn Shape (s:Shape, bounds:Box, points:Tuple<V3f>) :
  Shape(fabber(s), bounds)

public defn Shape (s:Shape, bounds:Box) :
  Shape(s, bounds, [])

public lostanza defn tree-delete (t:ref<Tree>) -> ref<False> :
  call-c ao_tree_delete(t.value)
  return false

public lostanza defn tree-save (t:ref<Tree>, filename:ref<String>) -> ref<False> :
  call-c ao_tree_save(t.value, addr!(filename.chars))
  return false

public lostanza defn tree-save-mesh (t:ref<Tree>, filename:ref<String>, box:ref<Box>, res:ref<Float>) -> ref<False> :
  call-c ao_tree_save_mesh_spread(t.value, x(lo(box)).value, x(hi(box)).value, y(lo(box)).value, y(hi(box)).value, z(lo(box)).value, z(hi(box)).value, res.value, addr!(filename.chars))
  return false

public lostanza defn tree-save-slice (t:ref<Tree>, filename:ref<String>, box:ref<Box>, res:ref<Float>) -> ref<False> :
  call-c ao_tree_save_slice_spread(t.value, x(lo(box)).value, x(hi(box)).value, y(lo(box)).value, y(hi(box)).value, z(lo(box)).value, res.value, addr!(filename.chars))
  return false

public lostanza defn get-vert-value (m:ref<AoMesh>, i:ref<Int>) -> ref<V3f> :
  val vert = m.value.verts[i.value]
  return V3f(new Float{vert.x}, new Float{vert.y}, new Float{vert.z})

public lostanza defn get-vert-index (m:ref<AoMesh>, i:ref<Int>) -> ref<V3i> :
  val tri = m.value.tris[i.value]
  return V3i(new Int{tri.a}, new Int{tri.b}, new Int{tri.c})

public lostanza defn tri-count (m:ref<AoMesh>) -> ref<Int> :
  return new Int{m.value.tri-count}

public lostanza defn vert-count (m:ref<AoMesh>) -> ref<Int> :
  return new Int{m.value.vert-count}

defn to-mesh (rm:AoMesh) -> Mesh :
  ;; println-all(["STZ MESH COUNT " tri-count(rm)])
  val tris = to-tuple $ for ti in 0 to tri-count(rm) seq : get-vert-index(rm, ti)
  ;; for (tri in tris, i in 0 to 4) do :
  ;;   println-all(["STZ TRI " tri])
  val verts = to-tuple $ for vi in 0 to vert-count(rm) seq : get-vert-value(rm, vi)
  ;; for (vert in verts, i in 0 to 4) do :
  ;;   println-all(["STZ VERT " i " " vert])
  Mesh(verts, tris)

public lostanza defn tree-render-mesh (t:ref<Tree>, box:ref<Box>, res:ref<Float>) -> ref<Mesh> :
  val out = call-c ao_tree_render_mesh_spread(t.value, x(lo(box)).value, x(hi(box)).value, y(lo(box)).value, y(hi(box)).value, z(lo(box)).value, z(hi(box)).value, res.value)
  val c-mesh = new AoMesh{out}
  val mesh = to-mesh(c-mesh)
  call-c ao_mesh_delete(out)
  return mesh

lostanza defn copy-bytes (b:ref<ByteArray>, p:ref<AoPixels>, n:ref<Int>) -> ref<False> :
  call-c memcpy(addr!(b.data), p.value.data, n.value)
  return false

defn to-pixels (p:AoPixels, res:Float) -> Pixels :
  val width = width(p)
  val height = height(p)
  val tot = width * height
  ;; println-all(["WIDTH " width " HEIGHT " height " NUM " tot])
  val data = ByteArray(tot)
  copy-bytes(data, p, tot)
  Pixels(V3i(width, height, 1), 1.0f / res, data)

public lostanza defn tree-render-pixels (t:ref<Tree>, box:ref<Box>, res:ref<Float>) -> ref<Pixels> :
  val out = call-c ao_tree_render_pixels_spread(t.value, x(lo(box)).value, x(hi(box)).value, y(lo(box)).value, y(hi(box)).value,  z(lo(box)).value, res.value)
  val c-pixels = new AoPixels{out}
  val pixels = to-pixels(c-pixels, res)
  call-c ao_pixels_delete(out)
  return pixels

lostanza defn get (contours:ref<AoContours>, c:ref<Int>, i:ref<Int>) -> ref<V3f> :
  val contour = contours.value.cs[c.value]
  val pt      = contour.pts[i.value]
  return V2f(new Float{pt.x}, new Float{pt.y})

lostanza defn get-contour-size (contours:ref<AoContours>, i:ref<Int>) -> ref<Int> :
  val contour = contours.value.cs[i.value]
  return new Int{contour.count}

lostanza defn num-contours (cs:ref<AoContours>) -> ref<Int> :
  return new Int{cs.value.count}

defn to-polygon (cs:AoContours) -> Polygon :
  val contours =
    for ci in 0 to num-contours(cs) seq :
      val points = for j in 0 to get-contour-size(cs, ci) seq : cs[ci, j]
      Contour(to-tuple $ points)
  Polygon(to-tuple $ contours)

public lostanza defn tree-render-slice (t:ref<Tree>, box:ref<Box>, res:ref<Float>) -> ref<Polygon> :
  val out = call-c ao_tree_render_slice_spread(t.value, x(lo(box)).value, x(hi(box)).value, y(lo(box)).value, y(hi(box)).value, z(lo(box)).value, res.value)
  val slice = new AoContours{out}
  val poly = to-polygon(slice)
  call-c ao_contours_delete(out)
  return poly

public lostanza defn fab-x () -> ref<FloField> :
  return FloFieldOp(new Tree{call-c ao_tree_x()}, String("X"), List())
public lostanza defn fab-y () -> ref<FloField> :
  return FloFieldOp(new Tree{call-c ao_tree_y()}, String("Y"), List())
public lostanza defn fab-z () -> ref<FloField> :
  return FloFieldOp(new Tree{call-c ao_tree_z()}, String("Z"), List())
public lostanza defn lit (f:ref<Float>) -> ref<FloField> :
  return FloFieldLit(new Tree{call-c ao_tree_const(f.value)}, f)
public lostanza defn lit (f:ref<Double>) -> ref<FloField> :
  return lit(to-float(f))
public lostanza defn opcode (name:ref<String>) -> ref<Int> :
  return new Int{call-c ao_opcode_enum(addr!(name.chars))}
public lostanza defn unary (op:ref<String>, t:ref<FloField>) -> ref<FloField> :
  return FloFieldOp(new Tree{call-c ao_tree_unary(opcode(op).value, tree(t).value)}, op, List(t))
public lostanza defn binary (op:ref<String>, t1:ref<FloField>, t2:ref<FloField>) -> ref<FloField> :
  return FloFieldOp(new Tree{call-c ao_tree_binary(opcode(op).value, tree(t1).value, tree(t2).value)}, op, List(t1, t2))
public defn min-lit () : lit(neg-inf)
public defn max-lit () : lit(pos-inf)

public defn nan-fill (x:FloField, y:FloField) -> FloField : binary("nan-fill", x, y)
public defn modulo (x:FloField, y:FloField) -> FloField :
  if lit?(x) and lit?(y): lit(modulo(lit-value(x), lit-value(y)))
  else : binary("mod", x, y)
public defn times (x:FloField, y:FloField) -> FloField : 
  if lit?(x) and lit?(y): lit(times(lit-value(x), lit-value(y)))
  else if lit?(x, 1.0f): y else if lit?(y, 1.0f): x 
  else if lit?(x, 0.0f) or lit?(y, 0.0f): lit(0.0f)
  else : binary("mul", x, y)
public defn min (x:FloField, y:FloField) -> FloField : 
  if lit?(x) and lit?(y): lit(min(lit-value(x), lit-value(y)))
  else if lit?(y) and lit-value(y) >= pos-inf: x
  else if lit?(x) and lit-value(x) >= pos-inf: y
  else : binary("min", x, y)
public defn max (x:FloField, y:FloField) -> FloField :
  if lit?(x) and lit?(y): lit(max(lit-value(x), lit-value(y)))
  else if lit?(y) and lit-value(y) <= pos-inf: x
  else if lit?(x) and lit-value(x) <= pos-inf: y
  else : binary("max", x, y)
public defn divide (x:FloField, y:FloField) -> FloField : 
  if lit?(x) and lit?(y): lit(divide(lit-value(x), lit-value(y)))
  else if lit?(y, 1.0f): x 
  else if lit?(x, 0.0f): x
  else : lit(0.0f)
public defn plus (x:FloField, y:FloField) -> FloField :
  if lit?(x) and lit?(y): lit(plus(lit-value(x), lit-value(y)))
  else if lit?(x, 0.0f): y else if lit?(y, 0.0f): x
  else if lit?(x) and op?(y, "add") and lit?(op-arg1(y)) : op-arg0(y) + lit(lit-value(x) + lit-value(op-arg1(y))) ;; add(lx, add(y, ly)) = add(y, lx + ly)
  else if lit?(x) and op?(y, "sub") and lit?(op-arg1(y)) : op-arg0(y) + lit(lit-value(x) - lit-value(op-arg1(y))) ;; add(lx, sub(y, ly)) = add(y, lx - ly)
  else if lit?(y) and op?(x, "add") and lit?(op-arg1(x)) : op-arg0(x) + lit(lit-value(op-arg1(x)) + lit-value(y)) ;; add(add(x, lx), ly) = add(x, lx + ly)
  else if lit?(y) and op?(x, "sub") and lit?(op-arg1(x)) : op-arg0(x) + lit(lit-value(y) - lit-value(op-arg1(x))) ;; add(sub(x, lx), ly) = add(x, ly - lx)
  else : binary("add", x, y)
public defn minus (x:FloField, y:FloField) -> FloField : 
  if lit?(x) and lit?(y): lit(minus(lit-value(x), lit-value(y)))
  else if lit?(y, 0.0f): x
  else if lit?(x) and op?(y, "add") and lit?(op-arg1(y)) : lit(lit-value(x) - lit-value(op-arg1(y))) - op-arg0(y) ;; sub(lx, add(y, ly)) = sub(lx - ly, y)
  else if lit?(x) and op?(y, "sub") and lit?(op-arg1(y)) : lit(lit-value(x) + lit-value(op-arg1(y))) - op-arg0(y) ;; sub(lx, sub(y, ly)) = sub(lx + ly, y)
  else if lit?(y) and op?(x, "add") and lit?(op-arg1(x)) : op-arg0(x) + lit(lit-value(op-arg1(x)) - lit-value(y)) ;; sub(add(x, lx), ly) = sub(x, lx - ly)
  else if lit?(y) and op?(x, "sub") and lit?(op-arg1(x)) : op-arg0(x) - lit(lit-value(y) + lit-value(op-arg1(x))) ;; sub(sub(x, lx), ly) = sub(x, lx + ly)
  else : binary("sub", x, y)
public defn atan2 (x:FloField, y:FloField) -> FloField :
  if lit?(x) and lit?(y): lit(atan2(lit-value(x), lit-value(y)))
  else if lit?(x) and lit?(y): lit(atan2(lit-value(x), lit-value(y))) else: binary("atan2", x, y)
public defn sqrt (x:FloField) -> FloField :
  if lit?(x): lit(sqrt(lit-value(x))) else: unary("sqrt", x)
public defn sqr (x:FloField) -> FloField :
  if lit?(x): lit(lit-value(x) * lit-value(x)) else: unary("square", x)
public defn abs (x:FloField) -> FloField :
  if lit?(x): lit(abs(lit-value(x))) else: max(x, (- x))
public defn sin (x:FloField) -> FloField : 
  if lit?(x): lit(sin(lit-value(x))) else: unary("sin", x)
public defn cos (x:FloField) -> FloField : 
  if lit?(x): lit(cos(lit-value(x))) else: unary("cos", x)
public defn tan (x:FloField) -> FloField : 
  if lit?(x): lit(tan(lit-value(x))) else: unary("tan", x)
public defn asin (x:FloField) -> FloField : 
  if lit?(x): lit(asin(lit-value(x))) else: unary("asin", x)
public defn acos (x:FloField) -> FloField : 
  if lit?(x): lit(acos(lit-value(x))) else: unary("acos", x)
public defn exp (x:FloField) -> FloField : 
  if lit?(x): lit(exp(lit-value(x))) else: unary("exp", x)
public defn negate (x:FloField) -> FloField : 
  if lit?(x): lit(negate(lit-value(x))) else: unary("neg", x)

public defn clamp (n:FloField, mn:FloField, mx:FloField) -> FloField :
  min(mx, max(mn, n))

public deftype Vec3Field <: Hashable & Equalable
public defmulti x (v:Vec3Field) -> FloField
public defmulti y (v:Vec3Field) -> FloField
public defmulti z (v:Vec3Field) -> FloField
public defmulti id (v:Vec3Field) -> Int

var nxt-id = -1

defn new-id () :
  nxt-id = nxt-id + 1
  nxt-id

public defn Vec3Field (x:FloField, y:FloField, z:FloField) :
  val id = new-id()
  new Vec3Field :
    defmethod x (this) : x
    defmethod y (this) : y
    defmethod z (this) : z
    defmethod id (this) : id
    defmethod hash (this) : id

defmethod equal? (a:Vec3Field, b:Vec3Field) -> True|False :
  x(a) == x(b) and y(a) == y(b) and z(a) == z(b) 

public defn lit (v:V3f) -> Vec3Field :
  Vec3Field(lit(x(v)), lit(y(v)), lit(z(v)))

public defn Vec3Field (n:FloField) -> Vec3Field :
  Vec3Field(n, n, n)

defmethod print (o:OutputStream, v:Vec3Field) :
  print(o, "Vec3Field(%_, %_, %_)" % [x(v), y(v), z(v)])

public deftype Vec2Field <: Vec3Field

public defn Vec2Field (x:FloField, y:FloField) :
  new Vec2Field :
    defmethod x (this) : x
    defmethod y (this) : y
    defmethod z (this) : lit(0.0)

defmethod print (o:OutputStream, v:Vec2Field) :
  print(o, "Vec2Field(%_, %_)" % [x(v), y(v)])

public defn Vec2Field (n:FloField) -> Vec2Field :
  Vec2Field(n, n)

public defn xy (v:Vec3Field) -> Vec2Field :
  Vec2Field(x(v), y(v))

public defn yz (v:Vec3Field) -> Vec2Field :
  Vec2Field(y(v), z(v))

public defn xz (v:Vec3Field) -> Vec2Field :
  Vec2Field(x(v), z(v))

public defn abs (a:Vec3Field) -> Vec3Field :
  Vec3Field(abs(x(a)), abs(y(a)), abs(z(a)))

public defn max (a:Vec3Field, b:FloField) -> Vec3Field :
  Vec3Field(max(x(a), b), max(y(a), b), max(z(a), b))

public defn max (a:Vec3Field, b:Vec3Field) -> Vec3Field :
  Vec3Field(max(x(a), x(b)), max(y(a), y(b)), max(z(a), z(b)))

public defn min (a:Vec3Field, b:FloField) -> Vec3Field :
  Vec3Field(min(x(a), b), min(y(a), b), min(z(a), b))

public defn min (a:Vec3Field, b:Vec3Field) -> Vec3Field :
  Vec3Field(min(x(a), x(b)), min(y(a), y(b)), min(z(a), z(b)))

public defn plus (a:Vec3Field, b:Vec3Field) -> Vec3Field :
  Vec3Field(x(a) + x(b), y(a) + y(b), z(a) + z(b))

public defn minus (a:Vec3Field, b:Vec3Field) -> Vec3Field :
  Vec3Field(x(a) - x(b), y(a) - y(b), z(a) - z(b))

public defn negate (a:Vec3Field) -> Vec3Field :
  Vec3Field((- x(a)), (- y(a)), (- z(a)))

public defn times (s:FloField, v:Vec3Field) -> Vec3Field :
  Vec3Field(s * x(v), s * y(v), s * z(v))

public defn times (a:Vec3Field, b:Vec3Field) -> Vec3Field :
  Vec3Field(x(a) * x(b), y(a) * y(b), z(a) * z(b))

public defn times (m:Mat44, v:Vec3Field) -> Vec3Field :
  val px = x(v) * lit(m[0,0]) + y(v) * lit(m[1,0]) + z(v) * lit(m[2,0]) + lit(m[3,0])
  val py = x(v) * lit(m[0,1]) + y(v) * lit(m[1,1]) + z(v) * lit(m[2,1]) + lit(m[3,1])
  val pz = x(v) * lit(m[0,2]) + y(v) * lit(m[1,2]) + z(v) * lit(m[2,2]) + lit(m[3,2])
  val pw = x(v) * lit(m[0,3]) + y(v) * lit(m[1,3]) + z(v) * lit(m[2,3]) + lit(m[3,3])
  Vec3Field(px / pw, py / pw, pz / pw)

public defn dot (a:Vec3Field, b:Vec3Field) -> FloField :
  x(a) * x(b) + y(a) * y(b) + z(a) * z(b)

public defn len (v:Vec3Field) -> FloField :
  sqrt(dot(v, v))

public defn normalize (v:Vec3Field) -> Vec3Field :
  v / len(v)

public defn divide (a:Vec3Field, b:FloField) -> Vec3Field :
  Vec3Field(x(a) / b, y(a) / b, z(a) / b)

public defn divide (a:Vec3Field, b:Vec3Field) -> Vec3Field :
  Vec3Field(x(a) / x(b), y(a) / y(b), z(a) / z(b))

public defn modulo (a:Vec3Field, b:Vec3Field) -> Vec3Field :
  Vec3Field(y(a) * z(b) - z(a) * y(b),
            z(a) * x(b) - x(a) * z(b),
            x(a) * y(b) - y(a) * x(b))

public defn with-xyz (mat:Mat44, f:(Vec3Field) -> Vec3Field, s:Shape) -> Shape :
  Shape(fn (p): fab(s, f(p)), mat * bounds(s), tags(s), to-tuple $ seq({mat * _} points(s)))

public defmethod xyz (mat:Mat44, s:Shape) -> Shape :
  with-xyz(mat, fn (p) : inverse(mat) * p, s)

;; TODO
public defmethod rgb (c:V4f, s:Shape) -> Shape :
  s

public defn mov<?T> (dp:V3f, s:?T&Poseable) -> T :
  xyz(mov-mat44(dp), s)

;; public defn mov (dx:FloField, dy:FloField, f:Shape) -> FloField :
;;   mov(dx, dy, lit(0.0), f)

public defn degrees-to-radians (d:Float) -> Float :
  d * to-float(PI-F) / 180.0f

public defn radians-to-degrees (a:Float) -> Float :
  a * 180.0f / to-float(PI-F)

public defn rot-x<?T> (d:Float, s:?T&Poseable) -> T :
  xyz(rot-mat44(V3f(degrees-to-radians(d), 0.0f, 0.0f)), s)

public defn rot-y<?T> (d:Float, s:?T&Poseable) -> T :
  xyz(rot-mat44(V3f(0.0f, degrees-to-radians(d), 0.0f)), s)

public defn rot-z<?T> (d:Float, s:?T&Poseable) -> T :
  xyz(rot-mat44(V3f(0.0f, 0.0f, degrees-to-radians(d))), s)

public defn rot-x (d:Float) : rot-x{d, _}
public defn rot-y (d:Float) : rot-y{d, _}
public defn rot-z (d:Float) : rot-z{d, _}

public defn reflect-x<?T> (s:?T&Poseable) -> T : xyz(mag-mat44(V3f(-1.0f, 1.0f, 1.0f)), s)

public defn reflect-y<?T> (s:?T&Poseable) -> T : xyz(mag-mat44(V3f( 1.0f,-1.0f, 1.0f)), s)

public defn reflect-z<?T> (s:?T&Poseable) -> T : xyz(mag-mat44(V3f( 1.0f, 1.0f,-1.0f)), s)

public defn reflect-xy<?T> (s:?T&Poseable) -> T : xyz(reflect-xy-mat44(), s)

public defn reflect-xz<?T> (s:?T&Poseable) -> T : xyz(reflect-xz-mat44(), s)

public defn reflect-yz<?T> (s:?T&Poseable) -> T : xyz(reflect-yz-mat44(), s)

public defn mag<?T> (fac:Float, s:?T&Poseable) -> T : xyz(mag-mat44(fac), s)

public defn mag1<?T> (sa:Float, s:?T&Poseable) -> T : xyz(mag-mat44(sa), s)

public defn mag<?T> (fac:V3f, s:?T&Poseable) -> T : xyz(mag-mat44(fac), s)

public defn mag-x<?T> (sx:Float, s:?T&Poseable) -> T : xyz(mag-mat44(V3f(sx, 1.0f, 1.0f)), s)

public defn mag-y<?T> (sy:Float, s:?T&Poseable) -> T : xyz(mag-mat44(V3f(1.0f, sy, 1.0f)), s)

public defn mag-z<?T> (sz:Float, s:?T&Poseable) -> T : xyz(mag-mat44(V3f(1.0f, 1.0f, sz)), s)

public defn mag   (s:V3f)    : mag{s, _}
public defn mag1  (s:Float)  : mag-x{s, _}
public defn mag-x (sx:Float) : mag-x{sx, _}
public defn mag-y (sy:Float) : mag-y{sy, _}
public defn mag-z (sz:Float) : mag-z{sz, _}

defn shear-x-y (ymin:Float, ymax:Float, dx0:Float, dx1:Float, s:Shape) -> Shape :
  defn xf (p) :
    val f = (y(p) - lit(ymin)) / (lit(ymax) - y(p))
    Vec3Field(x(p) - lit(dx0) * (lit(1.0) - f) - lit(dx1) * f, y(p), z(p))  
  with-xyz(shear-x-y-mat44(ymin, ymax, dx0, dx1), xf, s)

public defn shear-x-y (h:Float, dx0:Float, dx1:Float, s:Shape) -> Shape :
  shear-x-y(dim-min(h), dim-max(h), dx0, dx1, s)

;; TODO : UPDATE BOUNDS
defn taper-x-y (ymin:Float, ymax:Float, s0:Float, s1:Float, s:Shape) -> Shape :
  defn xf (p) :
    val sc = lit(ymax - ymin) / ((lit(s1) * (y(p) - lit(ymin))) - (lit(s0) * (y(p) - lit(ymax))))
    Vec3Field(x(p) * sc, y(p), z(p))
  with-xyz(id-mat44(), xf, s)

;; TODO : UPDATE BOUNDS
defn taper-xy-z (zmin:Float, zmax:Float, s0:Float, s1:Float, s:Shape) -> Shape :
  defn xf (p) :
    val sc = lit(zmax - zmin) / ((lit(s1) * (z(p) - lit(zmin))) - (lit(s0) * (z(p) - lit(zmax))))
    Vec3Field(x(p) * sc, y(p) * sc, z(p))
  with-xyz(id-mat44(), xf, s)

public defn taper-xy-z (h:Float, s0:Float, s1:Float, s:Shape) -> Shape :
  taper-xy-z(dim-min(h), dim-max(h), s0, s1, s)

;; TODO : UPDATE BOUNDS
public defn revolve-y (s:Shape) -> Shape :
  with-xyz(id-mat44(), fn (p): Vec3Field(sqrt(sqr(x(p)) + sqr(z(p))), y(p), z(p)), s)

public defn unrevolve-y (s:Shape) -> Shape :
  with-xyz(mag-mat44(V3f(2.0f * PI-F, 1.0f, 1.0f)), fn (p): Vec3Field(z(p) * cos(x(p)), y(p), z(p) * sin(x(p))), s)
  ;; with-xyz(mag-mat44(V3f(2.0f * PI-F, 1.0f, 1.0f)), fn (p): Vec3Field(atan2(x(p), z(p)), y(p), sqrt(sqr(x(p)) + sqr(z(p)))), s)

;; TODO : UPDATE BOUNDS
public defn revolve-x (s:Shape) -> Shape :
  with-xyz(id-mat44(), fn (p): Vec3Field(x(p), sqrt(sqr(y(p)) + sqr(z(p))), z(p)), s)

public defn unrevolve-x (s:Shape) -> Shape :
  with-xyz(mag-mat44(V3f(1.0f, 2.0f * PI-F, 1.0f)), fn (p): Vec3Field(x(p), z(p) * cos(y(p)), z(p) * sin(y(p))), s)
  ;; with-xyz(mag-mat44(V3f(2.0f * PI-F, 1.0f, 1.0f)), fn (p): Vec3Field(x(p), atan2(y(p), z(p)), sqrt(sqr(y(p)) + sqr(z(p)))), s)

;; TODO : UPDATE BOUNDS
public defn xy (z:Float, s:Shape) -> Shape :
  with-xyz(id-mat44(), fn (p): Vec3Field(x(p), y(p), lit(z)), s)

public defn xy (s:Shape) -> Shape : xy(0.0f, s)

public defn circle (d:Float) -> Shape :
  val r = d * 0.5f
  Shape(fn (p): len(xy(p)) - lit(r), Box(V3f((- r), (- r), neg-inf), V3f(r, r, pos-inf)))

;; public defn circle (x:FloField, y:FloField, r:FloField) -> FloField :
;;   mov(x, y, {circle(r)})

public defn sphere (d:Float) -> Shape :
  val r = d * 0.5f
  Shape(fn (p): len(p) - lit(r), Box(V3f((- r), (- r), (- r)), V3f(r, r, r)))

;; public defn sphere (x:FloField, y:FloField, z:FloField, r:FloField) -> FloField :
;;   mov(x, y, z, {circle(r)})

public defn bit-or (a:Shape, b:Shape) -> Shape :
  Shape(fn (p): min(fab(a, p), fab(b, p)), bounds(a) | bounds(b),
        to-tuple $ unique $ cat(tags(a), tags(b))
        to-tuple $ cat(points(a), points(b)))

public defn union (args:Seqable<Shape>) -> Shape :
  reduce(bit-or, empty(), args)

public defn bit-and (a:Shape, b:Shape) -> Shape :
  Shape(fn (p): max(fab(a, p), fab(b, p)), bounds(a) & bounds(b),
        to-tuple $ unique $ cat(tags(a), tags(b))
        to-tuple $ cat(points(a), points(b)))

public defn intersection (args:Seqable<Shape>) -> Shape :
  reduce(bit-and, args)

public defn invert (s:Shape) -> Shape :
  Shape(fn (p): (- fab(s, p)), inf-box())

public defn rem (a:Shape, b:Shape) -> Shape :
  Shape(a & invert(b), bounds(a), points(a))

public defn rem (a:Shape, args:Seqable<Shape>) -> Shape :
  rem(a, union(args))

public defn rem (shapes:Seqable<Shape>) -> Shape :
  val s = to-seq(shapes)
  rem(next(s), s)

public defn offset (s:Shape, o:Float) -> Shape :
  Shape(fn (p): fab(s, p) - lit(o), fatten(bounds(s), o), tags(s), points(s))
  
public defn clearance (a:Shape, b:Shape, o:Float) -> Shape :
  Shape(a & invert(offset(b, (- o))), bounds(a), points(a))
  
public defn shell (s:Shape, o:Float) -> Shape :
  clearance(s, s, o)
  
public defn blend (a:Shape, b:Shape, m:Float) -> Shape :
  val joint = a | b
  val fillet = Shape(fn (p): sqrt(abs(fab(a, p))) + sqrt(abs(fab(b, p))) - lit(m), bounds(a) | bounds(b))
  joint | fillet
  
public defn morph (a:Shape, b:Shape, m:Float) -> Shape :
  Shape(fn (p): fab(a, p) * (lit(1.0) - lit(m)) + fab(b, p) * lit(m), bounds(a) | bounds(b))
  
defn rect (xmin:Float, ymin:Float, xmax:Float, ymax:Float) -> Shape :
  val b = Box(V3f(xmin, ymin, neg-inf), V3f(xmax, ymax, pos-inf))
  Shape(fn (p): max(max(lit(xmin) - x(p), x(p) - lit(xmax)), max(lit(ymin) - y(p), y(p) - lit(ymax))),
        Box(V3f(xmin, ymin, neg-inf), V3f(xmax, ymax, pos-inf)))

public defn dim-min (d:Float) -> Float : d * -0.5f
public defn dim-max (d:Float) -> Float : d *  0.5f

public defn dim-min (dim:V3f) -> V3f : V3f(dim-min(x(dim)), dim-min(y(dim)), dim-min(z(dim)))
public defn dim-max (dim:V3f) -> V3f : V3f(dim-max(x(dim)), dim-max(y(dim)), dim-max(z(dim)))

public defn rect (w:Float, h:Float) -> Shape :
  rect(dim-min(w), dim-min(h), dim-max(w), dim-max(h))

public defn rect (v0:V3f, v1:V3f, d:Float) -> Shape :
  val v = v1 - v0
  val a = atan2(y(v),x(v))
  mov(0.5f * (v0 + v1), rot-z(radians-to-degrees(a), rect(magnitude(v) + d, d)))

public defn square (d:Float) -> Shape :
  rect(d, d)

public defn edge (v0:V3f, v1:V3f) -> Shape :
  Shape(fn (p): lit(y(v1) - y(v0)) * (x(p) - lit(x(v0))) - lit(x(v1) - x(v0)) * (y(p) - lit(y(v0))),
        Box(v0) | Box(v1))

public defn convex (pts:Tuple<V3f>) -> Shape :
  val edges = for i in 0 to length(pts) seq :
                edge(pts[i], pts[(i + 1) % length(pts)])
  val shape = reduce(fn (a:Shape, b:Shape): a & b, edges)
  Shape(fabber(shape), reduce(bit-or, seq(Box, pts)))

public defn trim (v0:V3f, v1:V3f, s:Shape) -> Shape :
  val res = s & edge(v0, v1)
  Shape(fabber(res), bounds(s))

public defn to-field2 (m:Mesh) -> Shape :
  val verts = vertices(m)
  union(for face in faces(m) seq :
          triangle(verts[face[0]], verts[face[1]], verts[face[2]]))

public defn to-field2 (p:Polygon) -> Shape :
  to-field2(triangulate(p))

public defn triangle (a:V3f, b:V3f, c:V3f) -> Shape :
  convex([a, b, c])

defn extrude (zmin:Float, zmax:Float, shape:Shape) -> Shape :
  val b = bounds(shape)
  Shape(fn (p): max(fab(shape, p), max(lit(zmin) - z(p), z(p) - lit(zmax))),
        Box(V3f(x(lo(b)), y(lo(b)), zmin), V3f(x(hi(b)), y(hi(b)), zmax)))

public defn extrude (h:Float, shape:Shape) -> Shape :
  extrude(dim-min(h), dim-max(h), shape)

;;; DEPRECATE
defn cube (xmin:Float, ymin:Float, zmin:Float, xmax:Float, ymax:Float, zmax:Float) -> Shape :
  extrude(zmin, zmax, rect(xmin, ymin, xmax, ymax))

;;; DEPRECATE
public defn cube (w:Float, h:Float, d:Float) -> Shape :
  cube(dim-min(w), dim-min(h), dim-min(d), dim-max(w), dim-max(h), dim-max(d))

public defn cube (d:Float) -> Shape :
  cube(d, d, d)

public defn cube (xy:Float, z:Float) -> Shape :
  cube(xy, xy, z)

public defn cube (v:V3f) -> Shape :
  cube(x(v), y(v), z(v))

;; public defn box (dims:V3f) -> Shape :
;;   defn fab (p) :
;;     val d = abs(p) - lit(0.5f * dims)
;;     min(max(x(d),max(y(d),z(d))),lit(0.0)) + len(max(d,lit(0.0)))  
;;   Shape(fab, dims-to-box(dims))

public defn box (b:Box) -> Shape :
  cube(x(lo(b)), y(lo(b)), z(lo(b)), x(hi(b)), y(hi(b)), z(hi(b)))

public defn box (dims:V3f) -> Shape :
  defn fab (p) : len(max(abs(p) - lit(0.5f * dims), lit(0.0)))
  Shape(fab, dims-to-box(dims))

public defn round-box (dims:V3f, r:Float) -> Shape :
  offset(box(dims), r)

public defn cylinder (d:Float, h:Float) -> Shape :
  extrude(h, circle(d))

public defn capsule (a:V3f, b:V3f, d:Float) -> Shape :
  val r  = 0.5f * d
  defn fab (p) :
    val pa = p - lit(a)
    val ba = b - a
    val h  = clamp(dot(pa, lit(ba)) / lit(dot(ba, ba)), lit(0.0), lit(1.0))
    len(pa - h * lit(ba)) - lit(r)
  Shape(fab, fatten(Box(a, a) | Box(b, b), r))

public defn capsule (d:Float, h:Float) -> Shape :
  val r = 0.5f * h
  cylinder(d, h) | mov-z(r, sphere(d)) | mov-z((- r), sphere(d))

public defn capsule2 (a:V3f, b:V3f, d:Float) -> Shape :
  val r  = 0.5f * d
  defn fab (p) :
    val pa = xy(p) - lit(a)
    val ba = b - a
    val h  = clamp(dot(pa, lit(ba)) / lit(dot(ba, ba)), lit(0.0), lit(1.0))
    len(pa - h * lit(ba)) - lit(r)
  Shape(fab, fatten(Box(a, a) | Box(b, b), r))

public defn thicken (segments:Seqable<[V3f, V3f]>, f:(V3f, V3f, Float) -> Shape, d:Float) -> Shape :
  val caps = for [v0, v1] in segments seq : f(v0, v1, d)
  reduce(fn (a:Shape, b:Shape): a | b, caps)

public defn thicken (g:PolyLine|Contour|Polygon, f:(V3f, V3f, Float) -> Shape, d:Float) -> Shape :
  thicken(segments(g), f, d)

public defn cone (d:Float, h:Float) -> Shape :
  Shape(taper-xy-z(h, 1.0f, 0.0f, cylinder(d, h)),
        dims-to-box(V3f(d, d, h)))

public defn pyramid (d:Float, h:Float) -> Shape :
  Shape(taper-xy-z(h, 1.0f, 0.0f, extrude(h, rect(d, d))),
        dims-to-box(V3f(d, d, h)))

public defn torus (D:Float, d:Float) -> Shape :
  Shape(fn (p): len(Vec2Field(lit(D * 0.5f) - len(xy(p)), z(p))) - lit(d * 0.5f),
        dims-to-box(V3f(D + d, D + d, d)))

public defn space (gdims:V3f, shape:Shape) :
  val gratio = gdims / dims(bounds(shape))
  val fac    = min(gratio)
  mag1(fac, shape)

public defn empty () : Shape(lit{pos-inf}, min-box())
public defn full () : Shape(lit{neg-inf}, inf-box())

;; public defn space-x (gdim:Float, shape:Shape) : mag1(gdim / x(dims(bounds(shape))), shape)
;; public defn space-y (gdim:Float, shape:Shape) : mag1(gdim / y(dims(bounds(shape))), shape)
;; public defn space-z (gdim:Float, shape:Shape) : mag1(gdim / z(dims(bounds(shape))), shape)

public defmulti spacer<?T> (g:?T&Poseable, dims:V3f) -> T
defmethod spacer (g:Shape, gdims:V3f) : Shape(lit{pos-inf}, Box(dim-min(gdims), dim-max(gdims)))
defmethod spacer (g:Assembly, dims:V3f) : Assembly(BLACK, [ spacer(empty(), dims) ])

public defn spacer-x<?T> (gdim:Float, g:?T&Poseable) : spacer(g, V3f(gdim, 0.0f, 0.0f))
public defn spacer-y<?T> (gdim:Float, g:?T&Poseable) : spacer(g, V3f(0.0f, gdim, 0.0f))
public defn spacer-z<?T> (gdim:Float, g:?T&Poseable) : spacer(g, V3f(0.0f, 0.0f, gdim))

public defn spacer-x (gdim:Float) : spacer-x(gdim, empty())
public defn spacer-y (gdim:Float) : spacer-y(gdim, empty())
public defn spacer-z (gdim:Float) : spacer-z(gdim, empty())

public defn stack-idx<?T> (ishapes:Seqable<?T&Poseable>, idx:Int, dir:Float) -> Seq<T> :
  val shapes = to-tuple(ishapes)
  val tot = reduce(plus, for shape in shapes seq : dims(bounds(shape))[idx])
  var tot-fac = 0.0f
  val res =
    generate<T&Poseable> :
      for (child in shapes, i in 0 to false) do :
        val now-fac = dims(bounds(child))[idx] / tot
        val ctr     = center(bounds(child))[idx]
        val amount  = dir * (tot / 2.0f - (tot-fac + now-fac / 2.0f) * tot) - ctr
        val del     = amount * V3f-unit(idx)
        yield(mov(del, child))
        tot-fac = tot-fac + now-fac
  filter({ volume(dims(bounds(_))) > 0.0f }, res)

public defn stack-x<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  stack-idx(shapes, 0,  1.0f)

public defn stack-y<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  stack-idx(shapes, 1,  1.0f)

public defn stack-z<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  stack-idx(shapes, 2,  1.0f)

public deftype AnyGlue <: Poseable
public defmulti amount (g:AnyGlue) -> Float

public deftype Glue <: AnyGlue & Shape

public defn glue-amount<?T> (shape:?T&Poseable) -> Float :
  match(shape) :
    (g:AnyGlue) : amount(g)
    (s)         : 0.0f

public defn Glue (amount:Float) :
  new Glue :
    defmethod fabber (this): fn (p:Vec3Field) : lit(pos-inf)
    defmethod bounds (this): Box(V3f(0.0f, 0.0f, 0.0f), V3f(0.0f, 0.0f, 0.0f))
    defmethod amount (this): amount

public deftype AssemblyGlue <: AnyGlue & Assembly
defmulti glue (g:AssemblyGlue) -> Glue

public defn AssemblyGlue (glue:Glue) :
  new AssemblyGlue :
    defmethod glue (this) : glue
    defmethod color (this): BLACK
    defmethod bounds (this) : bounds(glue)
    defmethod amount (this) : amount(glue)

public defmulti glue-of<?T> (s:?T&Poseable, a:Float) -> T
defmethod glue-of (s:Shape, a:Float) -> Shape : Glue(a)
defmethod glue-of (s:Assembly, a:Float) -> Assembly : AssemblyGlue(Glue(a))

public defn glue-when<?T> (first?:True|False, shapes:Seqable<?T&Poseable>) -> Seq<T> :
  generate<T> :
    for (shape in shapes, i in 0 to false) do :
      if first? or i > 0:
        yield(glue-of(shape, 1.0f))
      yield(shape)

public defn glue-even<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  glue-when(true, shapes)

public defn glue-odd<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  glue-when(false, shapes)

public defn glue<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  glue-odd(shapes)

public defn assign-glue-idx<?T> (ishapes:Seqable<?T&Poseable>, target:Float, idx:Int) -> Seq<T> :
  val shapes = to-tuple(ishapes)
  val tot = reduce(plus, for shape in shapes seq : dims(bounds(shape))[idx])
  val glue-tot = reduce(plus, for shape in shapes seq : glue-amount(shape))
  val gap-tot = (target - tot)
  for shape in shapes seq :
    match(shape) :
      (g:AnyGlue&T) :
        val s = (amount(g) / glue-tot) * gap-tot * V3f-unit(idx)
        spacer(shape, s)
      (s)           : s

public defn interleave<?T> (a:Seqable<?T&Poseable>, b:Seqable<?T&Poseable>) -> Seq<T> :
  generate<T> :
    val [sa, sb] = [to-seq(a), to-seq(b)]
    let loop (a?:True|False = true) :
      if not empty?(sa) and not empty?(sa):
        yield(next(sa) when a? else next(sb))
        loop(not a?)

public defn stack-idx<?T> (d:Float, idx:Int, shapes:Seqable<?T&Poseable>) -> Seq<T> :
  stack-idx(assign-glue-idx(shapes, d, idx), idx, 1.0f)

public defn stack-x<?T> (w:Float, shapes:Seqable<?T&Poseable>) -> Seq<T> :
  stack-x(assign-glue-idx(shapes, w, 0))
public defn stack-y<?T> (h:Float, shapes:Seqable<?T&Poseable>) -> Seq<T> :
  stack-y(assign-glue-idx(shapes, h, 1))
public defn stack-z<?T> (d:Float, shapes:Seqable<?T&Poseable>) -> Seq<T> :
  stack-z(assign-glue-idx(shapes, d, 2))
public defn stack-x (w:Float) : stack-x{w, _}
public defn stack-y (h:Float) : stack-y{h, _}
public defn stack-z (d:Float) : stack-z{d, _}

public defn space-idx<?T> (iseps:Seqable<Float>, idx:Int, shapes:Seqable<?T&Poseable>) -> Seq<T> :
  val seps = to-tuple $ iseps
  val tot = reduce(plus, seps)
  val start = -0.5f * tot
  val offs = generate<Float> :
    let loop (off = start, i = 0) :
      yield(off)
      if i < length(seps) : loop(off + seps[i], i + 1)
  for (shape in shapes, off in offs) seq :
    mov(off * V3f-unit(idx), shape)

public defn space-x<?T> (seps:Seqable<Float>, shapes:Seqable<?T&Poseable>) : space-idx(seps, 0, shapes)
public defn space-y<?T> (seps:Seqable<Float>, shapes:Seqable<?T&Poseable>) : space-idx(seps, 1, shapes)
public defn space-z<?T> (seps:Seqable<Float>, shapes:Seqable<?T&Poseable>) : space-idx(seps, 2, shapes)

public defn uniform-space-idx<?T> (n:Int, sep:Float, idx:Int, shape:?T&Poseable) -> Seq<T> :
  space-idx(repeat(sep, n - 1), idx, repeat(shape, n))

public defn uniform-space-x<?T> (n:Int, sep:Float, shape:?T&Poseable) : uniform-space-idx(n, sep, 0, shape)
public defn uniform-space-y< ?T> (n:Int, sep:Float, shape:?T&Poseable) : uniform-space-idx(n, sep, 1, shape)
public defn uniform-space-z<?T> (n:Int, sep:Float, shape:?T&Poseable) : uniform-space-idx(n, sep, 2, shape)
public defn uniform-space-x (n:Int, sep:Float) : uniform-space-idx{n, sep, 0, _}
public defn uniform-space-y (n:Int, sep:Float) : uniform-space-idx{n, sep, 1, _}
public defn uniform-space-z (n:Int, sep:Float) : uniform-space-idx{n, sep, 2, _}

defn align-it<?T> (ishapes:Seqable<?T&Poseable>, value:(Box) -> Float, mov:(Float, T) -> T) -> Seq<T> :
  val shapes = to-tuple(ishapes)
  val target = reduce(union, seq(bounds, shapes))
  ;; val target = bounds(shapes[0])
  for (child in shapes) seq :
    mov(value(target) - value(bounds(child)), child)

public defn attach<?T> (src:?T&Poseable, spos:V3f, dst:?T&Poseable, dpos:V3f) -> Seqable<T> :
  [mov(dpos - spos, src), dst]

public defn attach<?T> (src:?T&Poseable, si:Int, dst:?T&Poseable, di:Int) -> Seqable<T> :
  attach(src, points(src)[si], dst, points(dst)[di])

public defn align-min-x<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  align-it(shapes, { x(lo(_)) }, mov-x)

public defn align-max-x<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  align-it(shapes, { x(hi(_)) }, mov-x)

public defn align-min-y<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  align-it(shapes, { y(lo(_)) }, mov-y)

public defn align-max-y<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  align-it(shapes, { y(hi(_)) }, mov-y)

public defn align-min-z<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  align-it(shapes, { z(lo(_)) }, mov-z)

public defn align-max-z<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  align-it(shapes, { z(hi(_)) }, mov-z)

public defmulti jit-poseable (p:Poseable) -> AnyTree

defmethod jit-poseable (s:Shape) -> BoundedTree :
  val e = fab(s, Vec3Field(fab-x(), fab-y(), fab-z()))
  ;; println-all(["E = " count(e)])
  BoundedTree(s, e)

defmethod jit-poseable (a:Assembly) -> TreeAssembly :
  TreeAssembly(mat(a), color(a), to-tuple $ seq(jit-poseable, children(a)))

public defn jit (g:Geom) -> Geom :
  match(g) :
    (p:Poseable) :  jit-poseable(p)
    (geom) :        geom

public var *resolution* = 8.0f
public var *render-offset* = 16.0f

public defn slice (z:Float, s:Shape) -> Polygon :
  val bt = jit(s) as BoundedTree
  val eps = *render-offset* ;; 1.0f / *resolution*
  val bds = Box(xy(lo(bounds(s)) + V3f((- eps), (- eps), z)), xy(hi(bounds(s)) + V3f(eps, eps, z)))
  val start = current-time-ms()
  val poly = tree-render-slice(tree(bt), bds, *resolution*)
  ;; println-all(["RENDER-SLICE = " to-float(current-time-ms() - start) * 0.001f])
  poly

public defn pixels (z:Float, s:Shape) -> Pixels :
  ;; println-all(["RENDER-PIXELS-START " bounds(s)])
  val bt = jit(s) as BoundedTree
  ;; val eps = *render-offset* ;; 1.0f / *resolution*
  val eps = 1.0f / *resolution*
  val bds = Box(xy(lo(bounds(s)) + V3f((- eps), (- eps), z)), xy(hi(bounds(s)) + V3f(eps, eps, z)))
  val start = current-time-ms()
  val pixels = tree-render-pixels(tree(bt), bds, *resolution*)
  ;; println-all(["RENDER-PIXELS = " to-float(current-time-ms() - start) * 0.001f])
  pixels

public defn dump (filename:String, s:Shape) -> False :
  val bt = jit(s) as BoundedTree
  tree-save(tree(bt), filename)

public defn save (z:Float, filename:String, s:Shape) -> False :
  val bt = jit(s) as BoundedTree
  tree-save-slice(tree(bt), filename, bounds(s), *resolution*)

public defn save (filename:String, s:Shape) -> False :
  val bt = jit(s) as BoundedTree
  tree-save-mesh(tree(bt), filename, bounds(s), *resolution*)

;;; PLATES

public var *explosion* = 0.25f

public defn weld (i-a-shapes:Seqable<Shape>, i-b-shapes:Seqable<Shape>) -> Seqable<Shape> :
  val [a-shapes, b-shapes] = [to-tuple $ i-a-shapes, to-tuple $ i-b-shapes]
  println-all(["WELDING " length(a-shapes) + length(b-shapes)])
  defn overlap? (a:Shape, b:Shape) -> True|False :
    val i = fatten(bounds(a) & bounds(b), EPS)
    val mid = dims(i)[sorted-indices(dims(i))[1]]
    val res = not empty?(i) and mid > (min(dims(bounds(a))) * 1.1f)
    println-all([" I " dims(i) " MID-I " mid " MIN-A " min(dims(bounds(a))) " RES = " res])
    res
  val res = to-tuple $ generate<Shape> :
    val bs-mated? = HashTable<Int, Int>()
    for (a in a-shapes, i in 0 to false) do :
      println-all(["WELD I " i " DIMS " dims(bounds(a))])
      val mates = to-tuple $ generate<Shape> :
        for (b in b-shapes, j in 0 to false) do :
          print-all(["CONSIDERING " i " / " j ": "])
          if overlap?(a, b) and not key?(bs-mated?, j) :
            yield(b)
            bs-mated?[j] = j
      println-all(["MATES " length(mates)])
      yield(a | union(mates))
    for (b in b-shapes, j in 0 to false) do :
      if not key?(bs-mated?, j) :
        println-all(["EXTRA B " j])
        yield(b)
  println-all(["WELDING " length(res) " TOTAL"])
  res

public defn weld (a-shapes:Poseable, b-shapes:Poseable) -> Seqable<Shape> :
  weld(shapes $ a-shapes, shapes $ b-shapes)

public defn weld (poseables:Seqable<Poseable>) -> Seqable<Shape> :
  reduce(weld, seq(shapes, poseables))

public defn square-tooth (i:Box, n-slots:Int) -> Shape :
  val idx       = max-idx(dims(i))
  val max-dim   = dims(i)[idx]
  val slot-dim  = max-dim / to-float(n-slots)
  cube(V3f(slot-dim, pos-inf, pos-inf))

public defn saw-tooth (i:Box, n-slots:Int) -> Shape :
  val idx       = max-idx(dims(i))
  val max-dim   = dims(i)[idx]
  val slot-dim  = max-dim / to-float(n-slots)
  val num       = to-int $ round $ (to-float(n-slots) / 2.0f)
  val xr        = 0.5f * max-dim / to-float(num)
  val yr        = dims(i)[mid-idx(dims(i))]
  val zd        = dims(i)[min-idx(dims(i))]
  extrude(zd, triangle(V2f(xr, (- yr)), V2f(0.0f, yr), V2f((- xr), (- yr))))

public defn get-even-teeth (i:Box, get-tooth:(Box, Int) -> Shape, i-n-slots:Int, slot-size:Float) -> Shape :
  val idx       = max-idx(dims(i))
  val max-dim   = dims(i)[idx]
  val n-slots   = i-n-slots when i-n-slots > 0 else (((to-int $ floor $ max-dim / slot-size) / 2) * 2 + 1)
  val num       = to-int $ round $ (to-float(n-slots) / 2.0f)
  val stooth    = square-tooth(i, n-slots)
  val tooth     = get-tooth(i, n-slots)
  defn gen-tooth (n:Int) : tooth ;; stooth when n == 0 or n == (num - 1) else tooth
  val teeth     = to-tuple $ seq(gen-tooth, 0 to num)
  val glued-teeth = to-tuple $ glue-when(n-slots % 2 == 0, teeth)
  ;; println-all(["N-SLOTS " n-slots " NUM " num " N-TEETH " length(teeth) " GLUED-TEETH " length(glued-teeth)])
  union $ stack-x(max-dim, glued-teeth)
  ;; println-all(["N-SLOTS " n-slots " DIMS " dims(i) " MAX-IDX " idx " SLOT-DIM " slot-dim " CTRI " center(i) " TDIMS " dims(bounds(tooths))])

public defn get-square-teeth (i:Box, n-slots:Int, slot-size:Float) :
  get-even-teeth(i, square-tooth, n-slots, slot-size)

public defn get-square-teeth (i:Box, slot-size:Float) : get-square-teeth(i, 0, slot-size)
public defn get-square-teeth (i:Box, n-slots:Int) : get-square-teeth(i, n-slots, 0.0f)

public defn rot-mat44 (src:V3f, dst:V3f) -> Mat44 :
  if src == dst :
    ;; println-all(["ROT NONE"])
    id-mat44()
  else :
    val idx = min-idx(src + dst)
    ;; println-all(["ROT " idx])
    if idx == 0 :
      reflect-yz-mat44()
    else if idx == 1 :
      reflect-xz-mat44()
    else : ;; if idx == 2 :
      reflect-xy-mat44()

public defn rot-mat44 (src0:V3f, src1:V3f, dst0:V3f, dst1:V3f) -> Mat44 :
  val mat0 = rot-mat44(src0, dst0)
  val mat1 = rot-mat44(mat0 * src1, dst1)
  mat0 * mat1

public defn rot-mat44 (src0:Int, src1:Int, dst0:Int, dst1:Int) -> Mat44 :
  ;; println-all(["ROT-MAT44 S0 " src0 " S1 " src1 " D0 " dst0 " D1 " dst1])
  rot-mat44(V3f-unit(src0), V3f-unit(src1), V3f-unit(dst0), V3f-unit(dst1))

public defn join-two-pieces (a:Shape, b:Shape, get-teeth:Box -> Shape) -> [Shape, Shape] :
  val i          = fatten(bounds(a) & bounds(b), EPS)
  val overlap    = box(i)
  val mid-idx    = mid-idx(dims(bounds(overlap)))
  val dir        = center(bounds(a))[mid-idx] - center(bounds(b))[mid-idx]
  ;; val [min-idx-a, min-idx-b] = [min-idx(dims(bounds(a))), min-idx(dims(bounds(b)))]
  ;; println-all(["MIN= " (min-idx-a == min-idx-b) " DIR " dir
  ;;              " DIMS-A " dims(bounds(a)) " DIMS-B " dims(bounds(b))
  ;;              " CTR-A " center(bounds(a))[mid-idx] " CTR-B " center(bounds(b))[mid-idx]
  ;;              " BOUNDS-A " bounds(a) " BOUNDS-B " bounds(b)])
  val raw-teeth* = get-teeth(i)
  val raw-teeth  = reflect-y(raw-teeth*) when dir < 0.0f else raw-teeth*
  val xform      = rot-mat44(0, 2, max-idx(dims(i)), min-idx(dims(bounds(a)))) * mov-mat44(center(i))
  val olap       = overlap ;; fast but conservative
  ;; val olap      = a & b ;; slow but precise
  val teeth      = olap & xyz(xform, raw-teeth)
  val pa         = rem(a, teeth)
  val neg-teeth  = rem(olap, teeth)
  val pb         = rem(b, neg-teeth)
  [pa, pb]

;; public defn join-two-pieces (a:Shape, b:Shape, get-slots-info:(Float, Float) -> [Int, Float, Float]) -> [Shape, Shape] :
;;   val i         = fatten(bounds(a) & bounds(b), EPS)
;;   val dims      = dims(i)
;;   val idx       = max-idx(dims)
;;   val [inslots, slot-off, slot-size] = get-slots-info(lo(i)[idx], dims[idx])
;;   val nslots    = inslots when inslots > 0 else to-int $ ceil $ dims[idx] / slot-size 
;;   val num       = to-int $ round $ (to-float(nslots) / 2.0f)
;;   val slot-dim  = (dims[idx] / to-float(nslots)) when inslots >= 0 else slot-size
;;   val tdims     = set-elt(V3f-fill(pos-inf),  idx, slot-dim)
;;   println-all(["INSLOTS " inslots " NSLOTS " nslots " SLOT-SIZE " slot-size " SLOT-DIM " slot-dim " NUM " num " TDIMS " tdims[idx]])
;;   val vslot-off = set-elt(V3f-fill(0.0f), idx, (- slot-off))
;;   val tooth     = cube(tdims)
;;   val tooths    = union $ stack-idx(slot-dim * to-float(nslots), idx, glue-when(nslots % 2 == 0, seq({ tooth }, 0 to num)))
;;   ;; println-all(["NUM " num " NSLOTS " nslots " IDX " idx " DIMS " dims " TDIMS " tdims[idx]])
;;   val overlap   = box(i)
;;   val teeth     = overlap & mov(center(i) + vslot-off, tooths)
;;   val pa        = rem(a, teeth)
;;   val neg-teeth = rem(overlap, teeth)
;;   val pb        = rem(b, neg-teeth)
;;   [pa, pb]

public defn all-combos (a:Seqable<Int>, b:Seqable<Int>) -> Seqable<[Int, Int]> :
  generate<[Int, Int]> :
    for i in a do :
      for j in b do :
        yield([i, j])

val EPS = 0.001f

public defn full-captured-on? (i:Box, a:Box, d:Int) :
  ;; val res = abs(lo(i)[d] - lo(a)[d]) > EPS and abs(hi(a)[d] - hi(i)[d]) > EPS
  val res = (lo(i)[d] - lo(a)[d]) > EPS and (hi(a)[d] - hi(i)[d]) > EPS
  ;; println-all(["CAPTURED-ON? " i " / " a " D " d " -> " res])
  res

public defn captured? (b1:Box, b2:Box) -> True|False :
  defn any-captured? (i:Box, a:Box, big-d:Int) :
    val res = any?(full-captured-on?{i, a, _}, filter({ _ != big-d}, 0 to 3))
    ;; println-all(["ANY-CAPTURED? " i " / " a " big-d " big-d " -> " res])
    res
  val intersection = b1 & b2
  val big-d = max-idx(dims(intersection))
  any-captured?(intersection, b1, big-d) and any-captured?(intersection, b2, big-d)

defn n-smalls (dims:V3f) :
  val elts = to-tuple $ lazy-qsort(seq(get{dims, _}, 0 to 3))
  val n    = for d in 1 to 3 count : abs(elts[0] - elts[d]) < EPS
  ;; println-all(["N-SMALLS ELTS " elts " N " n + 1])
  n + 1

public defn full-captured2d? (b1:Box, b2:Box) -> True|False :
  if n-smalls(dims(b1 & b2)) == 1 :
    val i = b1 & b2
    val [d0, d1] = [mid-idx(dims(i)), max-idx(dims(i))]
    val c0 = (full-captured-on?(i, b1, d0) and full-captured-on?(i, b2, d1))
    val c1 = (full-captured-on?(i, b1, d1) and full-captured-on?(i, b2, d0))
    c0 or c1
  else :
    false

public defn abutt-captured-on? (a:Box, b:Box, d:Int, dir:Int) :
  val hi? = lo(b)[d] - lo(a)[d] > EPS and abs(hi(b)[d] - hi(a)[d]) < EPS
  val lo? = abs(lo(b)[d] - lo(a)[d]) < EPS and hi(a)[d] - hi(b)[d] > EPS
  val res = lo? when dir == -1 else hi?
  ;; println-all(["  PARTIAL-CAPTURED-ON? D " d " DIR " dir " A " a " B " b " RES " res])
  res

public defn abutt-captured-on? (a:Box, b:Box, d:Int) :
  val res = (lo(b)[d] - lo(a)[d]) > (- EPS) and (hi(a)[d] - hi(b)[d]) > (- EPS)
  ;; println-all(["  PARTIAL-CAPTURED-ON? D " d " pA " a " B " b " RES " res])
  res

public defn abutt-captured2d? (b1:Box, b2:Box) -> True|False :
  val i = b1 & b2
  if n-smalls(dims(i)) == 1 :
    val [d0, d1] = [mid-idx(dims(i)), max-idx(dims(i))]
    val c0 = (abutt-captured-on?(b1, b2, d0) or abutt-captured-on?(b2, b1, d0))
    val c1 = (abutt-captured-on?(b1, b2, d1) or abutt-captured-on?(b2, b1, d1))
    ;; println-all(["ABUTT-CAPTURED2D? DIMS(i) " dims(i) " N-SMALLS " n-smalls(dims(i)) " C0 " c0 " C1 " c1 " RES " (c0 and c1)])
    ;; println-all(["ABUTT-CAPTURED2D? C " c])
    c0 and c1
    ;; c
  else :
    false

public defn join-pieces (elts:Seqable<Shape>,
                         default-get-teeth:Box -> Shape,
                         abutt-get-teeth:Box -> Shape,
                         get-teeths:Tuple<KeyValue<[Int,Int], (Box -> Shape)>>,
                         sames:Tuple<[Int, Int, V3f]>) :
  val pieces = to-array<Shape> $ elts
  defn lookup-get-teeth (i:Int, j:Int) -> (Box -> Shape) :
    label<(Box -> Shape)> return :  
      for kv in get-teeths do :
        val [ki, kj] = key(kv)
        if (ki == i and kj == j) or (ki == j and kj == i) :
          return(value(kv))
      if min-idx(dims(bounds(pieces[i]))) == min-idx(dims(bounds(pieces[j]))) :
        abutt-get-teeth
      else :
        default-get-teeth
  defn update (k:Int, nk:Shape) :
    pieces[k] = nk
    for [i, j, d] in sames do :
      if i == k :
        println-all(["SAME UPDATE " j " <- " i])
        pieces[j] = pieces[j] & mov(d, pieces[i])
  for i in 0 to length(pieces) do :
    for j in (i + 1) to length(pieces) do : 
      val [bi, bj] = [bounds(pieces[i]), bounds(pieces[j])]
      if not empty?(bi & bj) :
        val cap? = captured?(bi, bj)
        val get-teeth = get-square-teeth{_, 2} when cap? else lookup-get-teeth(i, j)
        ;; println-all(["JOINING I " i " J " j " CAP? " cap? ": "])
        val [ni, nj] = join-two-pieces(pieces[i], pieces[j], get-teeth)
        update(i, ni)
        update(j, nj)
  pieces

defn split-full-overlap (s0:Shape, s1:Shape, t:Float) -> [Shape, Shape] :
  val i = bounds(s0) & bounds(s1)
  val d = max-idx(dims(bounds(s0)))
  val o = dims(i)[d] / 3.0f
  val s0a = s0 & box(Box(lo(bounds(s0)), set-elt(hi(bounds(s0)), d, lo(i)[d] + o)))
  val s0b = s0 & box(Box(set-elt(lo(bounds(s0)), d, hi(i)[d] - o), hi(bounds(s0))))
  [s0a s0b]

defstruct Abuttment :
  dir : Int
  d : Int
  k : Int
  s : Shape

defmethod print (o:OutputStream, e:Abuttment) :
  print-all(o, ["ABUTTMENT DIR = " dir(e) " D = " d(e) " K = " k(e)])

defn split-abutt-overlap (i0:Int, s0:Shape, i1:Int, s1:Shape, t:Float) -> [Int, Shape] :
  val i   = bounds(s0) & bounds(s1)
  val d0  = mid-idx(dims(i))
  val d1  = max-idx(dims(i))
  ;; println-all(["SHAPES S0 " bounds(s0) " S1 " bounds(s1)])
  ;; val [dir, d, k, s] = label<[Int, Int, Int, Shape]> return :
  val abuttments = generate<Abuttment> :
    for (a in [s0, s1], b in [s1, s0], k in [i0, i1]) do :
      for d in [d0, d1] do :
        for dir in [-1, 1] do :
          if abutt-captured-on?(bounds(a), bounds(b), d, dir) :
            ;; println-all(["FOUND ABUTTMENT D " d " DIR " dir " K " k])
            yield(Abuttment(dir, d, k, a))
  val sabuttments = to-tuple $ lazy-qsort(d, abuttments)
  println-all(["ABUTTMENTS " sabuttments])
  if length(sabuttments) == 0 :
    println-all(["FAILED TO FIND ABUTTMENT"])
    [i0, s0]
  else :
    val a   = sabuttments[0]
    val o   = dims(i)[d(a)] / 3.0f
    val nsh = s(a) & box(Box(lo(bounds(s(a))), set-elt(hi(bounds(s(a))), d(a), lo(i)[d(a)] + o)))
    val nsl = s(a) & box(Box(set-elt(lo(bounds(s(a))), d(a), hi(i)[d(a)] - o), hi(bounds(s(a)))))
    val ns  = nsl when dir(a) == -1 else nsh
    [k(a), ns]

public defn split-overlaps (elts:Seqable<Shape>, t:Float) -> Seqable<Shape> :
  val pieces = to-vector<Shape> $ elts
  println-all(["SPLIT-OVERLAPS IN " length(pieces)])
  for (i in 0 to false, piece in pieces) do :
    println-all([i "  " bounds(piece)])
  let loop () :
    val restart? = label<True|False> restart:
      for i in 0 to length(pieces) do :
        for j in (i + 1) to length(pieces) do :
          val [bi, bj] = [bounds(pieces[i]), bounds(pieces[j])]
          ;; println-all(["I " i " J " j " BI " bi " BJ " bj])
          if not empty?(bi & bj) :
            ;; println-all(["CHECKING " i " AND " j])
            if full-captured2d?(bi, bj) :
              val [a, b] = split-full-overlap(pieces[i], pieces[j], t)
              println-all([  "  FULL SPLIT " bounds(a) " / " bounds(b)])
              pieces[i] = a
              add(pieces, b)
              restart(true)
            else if abutt-captured2d?(bi, bj) :
              val [k, a] = split-abutt-overlap(i, pieces[i], j, pieces[j], t)
              println-all([  "  ABUTT SPLIT K " k " " pieces[k] " -> " bounds(a)])
              pieces[k] = a
              restart(true)
      false
    if restart? : loop()
  ;; println-all(["  OUT " length(pieces)])
  pieces

;; defn quilt-one (s:Shape, mx:Float, d0:Int, d1:Int, t:Float) -> Seqable<Shape> :
;;   val bds   = bounds(s)
;;   val dms   = dims(bds)
;;   val n = to-int $ ceil(dms[d0] / (mx + 2.0f * t))
;;   val g = dms[d0] / to-float(n)
;;   val o = lo(bds)[d0]
;;   val [ni, phase] = [1, -0.5f] when d1 == 1 else [0, 0.0f]
;;   val res = to-tuple $ for i in 0 to (n + ni) seq :
;;     val l = o + ((to-float(i) + phase)     * g - t)
;;     val h = o + ((to-float(i + 1) + phase) * g + t)
;;     s & box(Box(set-elt(lo(bds), d0, l), set-elt(hi(bds), d0, h)))
;;   println-all(["SPLIT MX " mx " D0 " d0 " D1 " d1 " PHASE " phase " -> " to-tuple $ seq(bounds, res)])
;;   res

defn quilt-one (s:Shape, mx:Float, d0:Int, d1:Int, t:Float, parity:Int) -> Seqable<Shape> :
  val bds   = bounds(s)
  val dms   = dims(bds)
  val n = to-int $ ceil(dms[d0] / (mx + 2.0f * t))
  val g = dms[d0] / to-float(n)
  val o = lo(bds)[d0]
  val [ni, phase] = [1, -0.5f] when (d1 % 2) == parity else [0, 0.0f] ;; TODO: GENERALIZE FOR ALL AXES
  val res = to-tuple $ for i in 0 to (n + ni) seq :
    val l = o + ((to-float(i) + phase)     * g - t)
    val h = o + ((to-float(i + 1) + phase) * g + t)
    s & box(Box(set-elt(lo(bds), d0, l), set-elt(hi(bds), d0, h)))
  println-all(["SPLIT MX " mx " D0 " d0 " D1 " d1 " N " n " PHASE " phase " -> " to-tuple $ seq(bounds, res)])
  res

;;; SPLITS BIG PIECES INTO N PIECES ACCORDING TO 
public defn quilt (shape:Shape, stock-dims:V3f, parity:Int) -> Seqable<Shape> :
  val t = min(stock-dims)
  val shape-dims = dims(bounds(shape))
  val sorted-shape-dims-1 = to-tuple $ lazy-qsort(shape-dims)  
  val sorted-shape-dims-2 = V3f(sorted-shape-dims-1[0], sorted-shape-dims-1[2], sorted-shape-dims-1[1])
  val sorted-stock-dims = to-tuple $ lazy-qsort(stock-dims)
  val cmps-1 = to-tuple $ seq({1 when _ <= _ else 0}, sorted-shape-dims-1, sorted-stock-dims)
  val cmps-2 = to-tuple $ seq({1 when _ <= _ else 0}, sorted-shape-dims-2, sorted-stock-dims)
  val n-1 = reduce(plus, cmps-1)
  val n-2 = reduce(plus, cmps-2)
  ;; println-all(["N " n " SHAPE-DIMS " sorted-shape-dims " STOCK-DIMS " sorted-stock-dims " CMPS " cmps])
  if n-1 == 3 :
    [ shape ]
  else if n-1 == 2 :
    quilt-one(shape, sorted-stock-dims[2], max-idx(shape-dims), mid-idx(shape-dims), t, parity)
  else if n-2 == 2 :
    quilt-one(shape, sorted-stock-dims[1], max-idx(shape-dims), mid-idx(shape-dims), t, parity)
  else :
    val splits-0 = quilt-one(shape, sorted-stock-dims[2], max-idx(shape-dims), mid-idx(shape-dims), t, parity)
    to-tuple $ cat-all $ seq(quilt-one{_, sorted-stock-dims[1], mid-idx(shape-dims), max-idx(shape-dims), t, parity}, splits-0)

public defn join-pieces (elts:Seqable<Shape>, get-teeth:Box -> Shape) :
  join-pieces(elts, get-teeth, get-teeth, [], [])

;; TODO: LIMITED TO AXIS ALIGNED SHAPES
public defn smash<?T> (s:?T&Poseable) -> T :
  val bb    = bounds(s)
  val dims  = dims(bb)
  val idx   = min-idx(dims)
  val ctr   = center(bb)
  defn rot (s) : if idx == 0 : reflect-xz(s) else if idx == 1 : reflect-yz(s) else : s
  rot(mov((- ctr), s))

defn segment<?T> (shapes:Seqable<?T>, width:T -> Float, max-width:Float, space:Float) -> Seqable<Tuple<T>> :
  val row = Vector<T>()
  generate<Tuple<T>> :
    for pc in shapes do :
      val off = reduce(plus, join(seq(width, cat(row, [pc])), space))
      if off > max-width :
        yield(to-tuple $ row)
        clear(row)
      add(row, pc)
    if length(row) > 0 : yield(to-tuple $ row)

public defn nest (pcs:Seqable<Poseable>, size:V3f, space:Float) -> Seq<Assembly> :
  val rpcs  = seq(fn (pc): reflect-xy(pc) when max-idx(dims(bounds(pc))) != max-idx(size) else pc, pcs)
  val spcs  = to-tuple $ lazy-qsort({ y(dims(bounds(_))) }, rpcs)
  val rows  = to-tuple $ segment(spcs, { x(dims(bounds(_))) }, x(size), space)
  val pages = segment(rows, { y(dims(bounds(union(shapes $ Assembly $ _)))) }, y(size), space)
  for page in pages seq :
    val rrows = for row in page seq: Assembly(stack-x(join(row, spacer-x(space))))
    Assembly(stack-y(join(rrows, Assembly([ spacer-y(space) ]))))

defn num-to-bits (num:Int) -> Tuple<Int> :
  to-tuple $ for i in 2 through 0 by -1 seq : (num >> i) & 1

defn num-to-bitz (num:Int) -> Tuple<Tuple<Int>> :
  to-tuple $ for i in 2 through 0 by -1 seq : num-to-bits((num >> (i * 3)) & 7)

defn bits-to-num (bitz:Tuple<Int>) -> Int :
  reduce(fn (a, x): a * 2 + x, bitz)

defn bitz-to-num (bitz:Tuple<Tuple<Int>>) -> Int :
  reduce(fn (a, x): a * 8 + x, seq(bits-to-num, bitz))

defn canonicalize-bits (bits:Tuple<Int>) -> Tuple<Int> :
  val rbits = [bits[2], bits[1], bits[0]]
  if bits-to-num(bits) < bits-to-num(rbits): bits else: rbits

defn canonicalize-bitz (bitz:Tuple<Tuple<Int>>) -> Tuple<Tuple<Int>> :
  to-tuple $ seq(num-to-bits, lazy-qsort(seq(bits-to-num, seq(canonicalize-bits, bitz))))

defn check (form:Tuple<Tuple<Int>>) -> True|False :
  defn boxed? (dim:Int, idx:Int) :
    label<True|False> return :
      val dn? = for i in idx through 0 by -1 any? :
        form[dim][i] == 1
      val up? = for i in (idx + 1) to 3 any? :
        form[dim][i] == 1
      dn? and up?
  label<True|False> return :
    for i in 0 to 2 do :
      for j in 0 to 2 do :
        for k in 0 to 2 do :
          if boxed?(0, i) and boxed?(1, j) and boxed?(2, k) :
            return(false)
    true

public defn all-forms () :
  val forms = HashTable<Int, Tuple<Tuple<Int>>>()
  for i in 0 to (2 << 8) do :
    val bitz  = num-to-bitz $ i
    val cbitz = canonicalize-bitz $ bitz
    val cnum  = bitz-to-num $ cbitz
    val ok?   = count({ _ == 0}, seq(bits-to-num, cbitz)) <= 1
    val ck?   = check(cbitz)
    if ck? and ok? and not key?(forms, cnum) :
      ;; println-all(["I " i " CNUM " cnum " BITZ " bitz " CBITZ " cbitz " CK? " ck? " OK? " ok? " KEY? " key?(forms, cnum)])
      forms[cnum] = cbitz
  forms

public defstruct Config :
  n : Int
  ply-thickness : Float
  stock-dims : V3f
  stock-boundary : V3f
  xy-quilt-dims : V3f
  quilt-parity :Int
  default-get-teeth : Box -> Shape
  default-get-abutt-teeth : Box -> Shape
  get-teeths : Tuple<KeyValue<[Int,Int], (Box -> Shape)>>
  sames : Tuple<[Int, Int, V3f]> 
  num-extras : Int
  
public defn Config (n:Int, t:Float, stock-dims:V3f, stock-boundary:V3f, xy-quilt-dims:V3f, quilt-parity:Int) :
  Config(n, t, stock-dims, stock-boundary, xy-quilt-dims, quilt-parity,
         get-square-teeth{_, 5}, get-even-teeth{_, saw-tooth, 0, 1.0f * to-float(n) * t}, [], [], 0)

public defn Config (n:Int, t:Float) :
  Config(n, t, V2f(32.0f, 24.0f), V2f(0.25f, 0.25f), V2f(32.0f, 24.0f), 0)

public defn Config () : Config(1, 0.280f)

public defn t (c:Config) : to-float(n(c)) * ply-thickness(c)
public defn quilt-dims (c:Config) : xy-quilt-dims(c) + V3f(0.0f, 0.0f, t(c) + 0.0001f)

public defstruct Results :
  bks : Tuple<Shape>
  pcs : Tuple<Shape>

public defn Results (fm:Seqable<Shape>, c:Config) :
  val bks0 = to-tuple $ fm
  val bks1 = to-tuple $ cat-all $ seq(quilt{_, quilt-dims(c), quilt-parity(c)}, bks0)
  ;; val bks1 = bks0
  val bks  = to-tuple $ split-overlaps(bks1, t(c))
  val pcs = to-tuple $ join-pieces(bks, default-get-teeth(c), default-get-abutt-teeth(c), get-teeths(c), sames(c))
  ;; val pcs = bks
  Results(bks, pcs)

public defn assembled (pcs:Tuple<Shape>) :
  group $ pcs

public defn pieces (bks:Tuple<Shape>) :
  group $ bks

public defn nested (pcs:Tuple<Shape>, c:Config) :
  println-all(["NESTED"])
  val spcs = pcs[0 to (length(pcs) - num-extras(c))]
  val npcs = cat-all $ for i in 0 to n(c) seq : spcs 
  nest(seq(smash{ group $ [_] }, npcs), stock-dims(c), 0.25f)

public defn explode (elt:Poseable, a:Float) :
  val ctr = center(bounds(elt))
  mov(a * ctr, group $ [ elt ])

public defn exploded (pcs:Tuple<Shape>) :
  group $ seq(explode{_, *explosion*}, pcs)

public defn pixeled (pcs:Seqable<Shape>, c:Config) :
  for pc in pcs seq :
    pixels(0.0f, smash(pc))

public defn arranged (pcs:Tuple<Shape>, c:Config) :
  val smashed-pcs = reverse $ to-list $ lazy-qsort({ area(dims(bounds(_))) }, seq(smash, pcs))
  val grids = to-tuple $ seq(to-grid, pixeled(smashed-pcs, c))
  val sdims = to-v3i(*resolution* * (stock-dims(c) - 2.0f * stock-boundary(c))) + V3i(0, 0, 1)
  ;; val sdims = to-v3i(*resolution* * stock-dims(c)) + V3i(0, 0, 1)
  val arrangement = Arrangement(sdims, 1.0f / *resolution*)
  println-all(["STOCK IDIMS " stock-dims(arrangement)])
  for (grid in grids, i in 0 to false) do :
    ;; println-all(["ADDING " i " IDIMS " idims(grid)])
    add(arrangement, uniquify{_, arrangement} $ SuperPart(i, grid))
  println-all([length(pages(arrangement)) " PAGES"])
  ;; for (p in pages(arrangement), page-num in 0 to false) seq :
  ;;   to-pixels $ result(p)
  for (p in pages(arrangement), page-num in 0 to false) seq :
    group $ generate<Shape> :
      ;; val base-off = dim(result(p)) * V2f(1.0f, 1.0f) + stock-boundary(c)
      val base-off = stock-boundary(c) - dim(result(p)) * V2f(1.0f, 1.0f)
      for (page-pose in poses(arrangement), pc-id in 0 to false) do :
        if page(page-pose) == page-num :
          val angle = angle(pose(page-pose))
          ;; val off = pt-of(result(p), translation(pose(page-pose))) + ctr-pt(rotate(angle, grids[pc-id])) + stock-boundary(c)
          val off = base-off + pt-of(result(p), translation(pose(page-pose))) + ctr-pt(rotate(angle, grids[pc-id]))
          ;; println-all(["IDX " translation(pose(page-pose)) " OFF " off " ROT " angle " BOUNDS " bounds(smashed-pcs[pc-id])])
          yield(mov(off, rot-z(to-float $ angle, smashed-pcs[pc-id])))

public defn sliced (pcs:Tuple<Shape>, c:Config) :
  val pages = to-tuple $ arranged(pcs, c) ;; nested(pcs, c)
  println-all([length(pages) " PAGES"])
  for page in pages seq :
    val parts = union $ shapes $ page
    println-all(["  " dims(bounds(parts))])
    slice(0.0f, parts)

public defn group (elts:Seqable<Poseable>) : Assembly(elts)

public defn svgd (c:Config, res:Results) :
  for (slice in sliced(pcs(res), c), i in 0 to false) do :
    val mag-sliced = mag-mat44(V2f(72.0f, 72.0f)) * slice
    val half = 0.5f * stock-dims(c)
    val bbox = Box(-72.0f * half, 72.0f * half)
    svg(mag-sliced, string-join(["tst-" i ".svg"]), bbox)
