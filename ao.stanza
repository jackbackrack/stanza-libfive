defpackage ao :
  import core
  import math
  import collections
  import utils
  import glu
  import geom
  import font

extern tree_x: () -> ptr<?>
extern tree_y: () -> ptr<?>
extern tree_z: () -> ptr<?>
extern tree_const: (float) -> ptr<?>
extern tree_unary: (int, ptr<?>) -> ptr<?>
extern tree_binary: (int, ptr<?>, ptr<?>) -> ptr<?>
extern opcode_enum: (ptr<?>) -> int
extern tree_export_slice: (ptr<?>, ptr<?>, float, float, float, float, float, float) -> int
extern tree_export_mesh: (ptr<?>, ptr<?>, float, float, float, float, float, float, float) -> int
;; extern tree_render_mesh: (ptr<?>, ptr<ptr<float>>, float, float, float, float, float, float, float) -> int
extern tree_render_mesh: (ptr<?>, ptr<int>, ptr<ptr<float>>, ptr<int>, ptr<ptr<int>>, float, float, float, float, float, float, float) -> int
extern tree_render_slice: (ptr<?>, float, float, float, float, float, float) -> ptr<Contours>
extern contours_delete: (ptr<Contours>) -> int
extern window_show_tree: (ptr<?>, ptr<?>, ptr<?>) -> ptr<?>
extern ao_run: () -> ptr<?>
extern ao_halt: () -> ptr<?>
extern printf: (ptr<?>, ? ...) -> int
extern free: (ptr<?>) -> int

public lostanza deftype Contours :
  xs : ptr<ptr<float>>
  ys : ptr<ptr<float>>
  sizes : ptr<int>
  size : int

public lostanza deftype Tree <: Geom :
  value: ptr<?>

defmethod print (o:OutputStream, t:Tree) :
  print-all(o, ["Tree()"])

public deftype FloField <: Equalable
public defmulti tree (f:FloField) -> Tree
public defmulti count (f:FloField) -> Int

public defstruct FloFieldLit <: FloField :
  tree: Tree with: (as-method => true)
  value: Float

defn lit? (f:FloField) -> True|False :
  match(f):
  (l:FloFieldLit) : true
  (o:FloFieldOp) : false

defn lit? (f:FloField, v:Float) -> True|False :
  match(f):
  (l:FloFieldLit) : value(l) == v
  (o:FloFieldOp) : false

defn lit-value (f:FloField) -> Float :
  match(f):
  (l:FloFieldLit) : value(l)
  (o:FloFieldOp) : 0.0f

defmethod print (s:OutputStream, f:FloFieldLit) :
  print(s, "LIT(%_)" % [value(f)])

defmethod equal? (a:FloFieldLit, b:FloFieldLit) -> True|False :
  value(a) == value(b)

defmethod count (a:FloFieldLit) -> Int :
  1

public defstruct FloFieldOp <: FloField :
  tree: Tree with: (as-method => true)
  op: String
  args: List<FloField>

defmethod print (s:OutputStream, f:FloFieldOp) :
  print(s, "%_(%,)" % [op(f), args(f)])

defmethod equal? (a:FloFieldOp, b:FloFieldOp) -> True|False :
  op(a) == op(b) and all?(equal?, args(a), args(b))

defmethod count (f:FloFieldOp) -> Int :
  1 + reduce(plus, 0, seq(count, args(f)))

public deftype Poseable <: Geom
public defmulti bounds (p:Poseable) -> Box
public defmulti points (p:Poseable) -> Tuple<V3f>
public defmulti mov<?T> (dp:V3f, p:?T&Poseable) -> T
public defmulti shapes (p:Poseable) -> Seqable<Shape>

public defn mov-x<?T> (dx:Float, p:?T&Poseable) -> T : mov(V3f(dx, 0.0f, 0.0f), p)
public defn mov-y<?T> (dy:Float, p:?T&Poseable) -> T : mov(V3f(0.0f, dy, 0.0f), p)
public defn mov-z<?T> (dz:Float, p:?T&Poseable) -> T : mov(V3f(0.0f, 0.0f, dz), p)

;;; ASSEMBLIES

public deftype RealPoseable <: Poseable
public defmulti layers (p:RealPoseable) -> Seqable<Layer>

public deftype Layer <: RealPoseable
public defmulti pos (l:Layer) -> V3f
public defmulti shape (l:Layer) -> Shape
public defmulti color (l:Layer) -> V4f

public defn Layer (bounds:Box, pos:V3f, color:V4f, shape:Shape) :
  new Layer :
    defmethod pos (this) : pos
    defmethod bounds (this) : bounds
    defmethod points (this) : points(shape)
    defmethod shape (this) : shape
    defmethod color (this) : color
    defmethod layers (this) : [this]

public defn Layer (color:V4f, shape:Shape) :
  Layer(bounds(shape), V3f(0.0f, 0.0f, 0.0f), color, shape)

public defmethod mov (dp:V3f, p:Layer) -> Layer :
  Layer(mov-mat44(dp) * bounds(p), pos(p) + dp, color(p), shape(p))

public defmethod shapes (p:Layer) : [ mov(pos(p), shape(p)) ]

public deftype Layoutable <: RealPoseable
public defmulti blocks (l:Layoutable) -> Seqable<Block>

public deftype Block <: Layoutable

public defn Block (layers:Collection<Layer>) :
  new Block :
    defmethod bounds (this) : reduce(bit-or, for layer in layers seq: bounds(layer))
    defmethod layers (this) : layers
    defmethod blocks (this) : [this]
    defmethod points (this) : to-tuple $ cat-all $ seq(points, layers)

public defn Block (layers:Seq<Layer>) : Block(to-tuple $ layers)
public defn Block (color:V4f, shape:Shape) : Block([Layer(color, shape)])
public defn Block (shape:Shape) : Block(WHITE, shape)

public defmethod mov (dp:V3f, b:Block) -> Block :
  Block(to-tuple $ seq(mov{dp, _}, layers(b)))

public defmethod shapes (p:Block) : cat-all $ seq(shapes, layers(p))

public deftype Layout <: Layoutable

public defn Layout (elts:Collection<Layoutable>) :
  new Layout :
    defmethod bounds (this) : reduce(bit-or, for elt in elts seq: bounds(elt))
    defmethod blocks (this) : cat-all $ seq(blocks, elts)
    defmethod points (this) : to-tuple $ cat-all $ seq(points, elts)

public defn Layout (blocks:Seq<Layoutable>) : Layout(to-tuple $ blocks)

public defmethod mov (dp:V3f, l:Layout) -> Layout :
  Layout(to-tuple $ seq(mov{dp, _}, blocks(l)))

public defmethod shapes (p:Layout) : cat-all(seq(shapes, blocks(p)))

public defstruct BoundedTree <: Geom :
  bounds : Box
  tree:    Tree

public defstruct TreeLayer <: Geom :
  pos : V3f
  color : V4f
  tree : BoundedTree

public defstruct TreeBlock <: Geom :
  layers : Collection<TreeLayer>

public defstruct TreeLayout <: Geom :
  blocks : Collection<TreeBlock>

;;; SHAPE

public deftype Shape <: Poseable
public defmulti fabber (s:Shape) -> ((Vec3Field) -> FloField)
public defmulti cache (s:Shape) -> HashTable<Vec3Field,FloField>

public defn Shape (fabber:(Vec3Field) -> FloField, bounds:Box, points:Tuple<V3f>) :
  val cache = HashTable<Vec3Field,FloField>()
  new Shape :
    defmethod fabber (this) : fabber
    defmethod bounds (this) : bounds
    defmethod points (this) : points
    defmethod cache (this) : cache

public defn Shape (fabber:(Vec3Field) -> FloField, bounds:Box) :
  Shape(fabber, bounds, [])

public defn add-points (s:Shape, points:Tuple<V3f>) :
  Shape(fabber(s), bounds(s), points)

public defn add-min-x-point (s:Shape) :
  add-points(s, [V3f(x(lo(bounds(s))), 0.0f, 0.0f)])
public defn add-max-x-point (s:Shape) :
  add-points(s, [V3f(x(hi(bounds(s))), 0.0f, 0.0f)])
public defn add-min-y-point (s:Shape) :
  add-points(s, [V3f(0.0f, y(lo(bounds(s))), 0.0f)])
public defn add-max-y-point (s:Shape) :
  add-points(s, [V3f(0.0f, y(hi(bounds(s))), 0.0f)])
public defn add-min-z-point (s:Shape) :
  add-points(s, [V3f(0.0f, 0.0f, z(lo(bounds(s))))])
public defn add-max-z-point (s:Shape) :
  add-points(s, [V3f(0.0f, 0.0f, z(hi(bounds(s))))])

defmethod print (s:OutputStream, o:Shape) :
  print-all(s, ["Shape(" bounds(o) ")"])

defn fab (s:Shape, p:Vec3Field) -> FloField :
  if key?(cache(s), p) :
    cache(s)[p]
  else :
    val f = fabber(s)(p)
    cache(s)[p] = f
    ;; if length(cache(s)) > 1 :
    ;;   println-all(["MISS " to-tuple $ keys(cache(s))])
    f

public defn Shape (s:Shape, bounds:Box, points:Tuple<V3f>) :
  Shape(fabber(s), bounds)

public defn Shape (s:Shape, bounds:Box) :
  Shape(s, bounds, [])

public lostanza defn tree-export-mesh (t:ref<Tree>, filename:ref<String>, box:ref<Box>, res:ref<Float>) -> ref<False> :
  call-c tree_export_mesh(t.value, addr!(filename.chars), x(lo(box)).value, x(hi(box)).value, y(lo(box)).value, y(hi(box)).value, z(lo(box)).value, z(hi(box)).value, res.value)
  return false

public lostanza defn tree-export-slice (t:ref<Tree>, filename:ref<String>, box:ref<Box>, res:ref<Float>) -> ref<False> :
  call-c tree_export_slice(t.value, addr!(filename.chars), x(lo(box)).value, x(hi(box)).value, y(lo(box)).value, y(hi(box)).value, z(lo(box)).value, res.value)
  return false

;; public lostanza deftype RenderMesh :
;;   length: int
;;   value: ptr<float>

public lostanza deftype RenderMesh :
  n-verts: int
  verts: ptr<float>
  n-tris: int
  tris: ptr<int>

public lostanza defn n-verts (m:ref<RenderMesh>) -> ref<Int> :
  return new Int{m.n-verts}

public lostanza defn get-vert-value (m:ref<RenderMesh>, i:ref<Int>) -> ref<Float> :
  return new Float{m.verts[i.value]}

public lostanza defn n-tris (m:ref<RenderMesh>) -> ref<Int> :
  return new Int{m.n-tris}

public lostanza defn get-vert-index (m:ref<RenderMesh>, i:ref<Int>) -> ref<Int> :
  return new Int{m.tris[i.value]}

defn to-mesh (rm:RenderMesh) -> Mesh :
  val tris = generate<V3i> :
    for ti in 0 to n-tris(rm) do :
      val toff = ti * 3
      yield(V3i(get-vert-index(rm, toff + 0), get-vert-index(rm, toff + 1), get-vert-index(rm, toff + 2)))
  val verts = generate<V3f> :
    for vi in 0 to n-verts(rm) do :
      val voff = vi * 3
      yield(V3f(get-vert-value(rm, voff + 0), get-vert-value(rm, voff + 1), get-vert-value(rm, voff + 2)))
  Mesh(to-tuple(verts), to-tuple(tris))

public lostanza defn tree-render-mesh (t:ref<Tree>, box:ref<Box>, res:ref<Float>) -> ref<Mesh> :
  val out = new RenderMesh{0, 0L as ptr<float>, 0, 0L as ptr<int>}
  val len = call-c tree_render_mesh(t.value, addr!(out.n-verts), addr!(out.verts), addr!(out.n-tris), addr!(out.tris), x(lo(box)).value, x(hi(box)).value, y(lo(box)).value, y(hi(box)).value, z(lo(box)).value, z(hi(box)).value, res.value)
  val mesh = to-mesh(out)
  call-c free(out.verts)
  call-c free(out.tris)
  return mesh

lostanza defn get-x (cs:ref<Contours>, c:ref<Int>, i:ref<Int>) -> ref<Float> :
  return new Float{cs.xs[c.value][i.value]}

lostanza defn get-y (cs:ref<Contours>, c:ref<Int>, i:ref<Int>) -> ref<Float> :
  return new Float{cs.ys[c.value][i.value]}

lostanza defn get-contour-size (cs:ref<Contours>, i:ref<Int>) -> ref<Int> :
  return new Int{cs.sizes[i.value]}

lostanza defn num-contours (cs:ref<Contours>) -> ref<Int> :
  return new Int{cs.size}

defn to-polygon (cs:Contours) -> Polygon :
  val contours =
    for ci in 0 to num-contours(cs) seq :
      val points =
        for j in 0 to get-contour-size(cs, ci) seq :
          V2f(get-x(cs, ci, j), get-y(cs, ci, j))
      Contour(to-tuple $ points)
  Polygon(to-tuple $ contours)

public lostanza defn tree-render-slice (t:ref<Tree>, box:ref<Box>, res:ref<Float>) -> ref<Polygon> :
  val out = call-c tree_render_slice(t.value, x(lo(box)).value, x(hi(box)).value, y(lo(box)).value, y(hi(box)).value, z(lo(box)).value, res.value)
  val contours = new Contours{out.xs, out.ys, out.sizes, out.size}
  val poly = to-polygon(contours)
  call-c contours_delete(out)
  return poly

public lostanza defn show (t:ref<Tree>, filename:ref<String>, name:ref<String>) -> ref<False> :
  call-c window_show_tree(addr!(filename.chars), addr!(name.chars), t.value)
  return false

public defn show (t:Tree) :
  show(t, "ao.stanza", "shape")

public lostanza defn ao-run () -> ref<False>  :
  call-c ao_run()
  return false

public lostanza defn ao-halt () -> ref<False> :
  call-c ao_halt()
  return false

public lostanza defn fab-x () -> ref<FloField> :
  return FloFieldOp(new Tree{call-c tree_x()}, String("X"), List())
public lostanza defn fab-y () -> ref<FloField> :
  return FloFieldOp(new Tree{call-c tree_y()}, String("Y"), List())
public lostanza defn fab-z () -> ref<FloField> :
  return FloFieldOp(new Tree{call-c tree_z()}, String("Z"), List())
public lostanza defn lit (f:ref<Float>) -> ref<FloField> :
  return FloFieldLit(new Tree{call-c tree_const(f.value)}, f)
public lostanza defn lit (f:ref<Double>) -> ref<FloField> :
  return lit(to-float(f))
public lostanza defn opcode (name:ref<String>) -> ref<Int> :
  return new Int{call-c opcode_enum(addr!(name.chars))}
public lostanza defn unary (op:ref<String>, t:ref<FloField>) -> ref<FloField> :
  return FloFieldOp(new Tree{call-c tree_unary(opcode(op).value, tree(t).value)}, op, List(t))
public lostanza defn binary (op:ref<String>, t1:ref<FloField>, t2:ref<FloField>) -> ref<FloField> :
  return FloFieldOp(new Tree{call-c tree_binary(opcode(op).value, tree(t1).value, tree(t2).value)}, op, List(t1, t2))
public defn min-lit () : lit(FLOAT-MIN)
public defn max-lit () : lit(FLOAT-MAX)

public defn nan-fill (x:FloField, y:FloField) -> FloField : binary("nan-fill", x, y)
public defn modulo (x:FloField, y:FloField) -> FloField :
  if lit?(x) and lit?(y): lit(modulo(lit-value(x), lit-value(y))) else : binary("mod", x, y)
public defn times (x:FloField, y:FloField) -> FloField : 
  if lit?(x) and lit?(y): lit(times(lit-value(x), lit-value(y)))
  else if lit?(x, 1.0f): y else if lit?(y, 1.0f): x else : binary("mul", x, y)
public defn min (x:FloField, y:FloField) -> FloField : 
  if lit?(x) and lit?(y): lit(min(lit-value(x), lit-value(y)))
  else if lit?(y, FLOAT-MAX): x else if lit?(x, FLOAT-MAX): y else : binary("min", x, y)
public defn max (x:FloField, y:FloField) -> FloField :
  if lit?(x) and lit?(y): lit(max(lit-value(x), lit-value(y)))
  else if lit?(y, FLOAT-MIN): x else if lit?(x, FLOAT-MIN): y else : binary("max", x, y)
public defn divide (x:FloField, y:FloField) -> FloField : 
  if lit?(x) and lit?(y): lit(divide(lit-value(x), lit-value(y)))
  else if lit?(y, 1.0f): x else : binary("div", x, y)
public defn plus (x:FloField, y:FloField) -> FloField :
  if lit?(x) and lit?(y): lit(plus(lit-value(x), lit-value(y)))
  else if lit?(x, 0.0f): y else if lit?(y, 0.0f): x else : binary("add", x, y)
public defn minus (x:FloField, y:FloField) -> FloField : 
  if lit?(x) and lit?(y): lit(minus(lit-value(x), lit-value(y)))
  else if lit?(y, 0.0f): x else : binary("sub", x, y)
public defn atan2 (x:FloField, y:FloField) -> FloField :
  if lit?(x) and lit?(y): lit(atan2(lit-value(x), lit-value(y)))
  else if lit?(x) and lit?(y): lit(atan2(lit-value(x), lit-value(y))) else: binary("atan2", x, y)
public defn sqrt (x:FloField) -> FloField :
  if lit?(x): lit(sqrt(lit-value(x))) else: unary("sqrt", x)
public defn sqr (x:FloField) -> FloField :
  if lit?(x): lit(lit-value(x) * lit-value(x)) else: unary("square", x)
public defn abs (x:FloField) -> FloField :
  if lit?(x): lit(abs(lit-value(x))) else: unary("abs", x)
public defn sin (x:FloField) -> FloField : 
  if lit?(x): lit(sin(lit-value(x))) else: unary("sin", x)
public defn cos (x:FloField) -> FloField : 
  if lit?(x): lit(cos(lit-value(x))) else: unary("cos", x)
public defn tan (x:FloField) -> FloField : 
  if lit?(x): lit(tan(lit-value(x))) else: unary("tan", x)
public defn asin (x:FloField) -> FloField : 
  if lit?(x): lit(asin(lit-value(x))) else: unary("asin", x)
public defn acos (x:FloField) -> FloField : 
  if lit?(x): lit(acos(lit-value(x))) else: unary("acos", x)
public defn exp (x:FloField) -> FloField : 
  if lit?(x): lit(exp(lit-value(x))) else: unary("exp", x)
public defn negate (x:FloField) -> FloField : 
  if lit?(x): lit(negate(lit-value(x))) else: unary("neg", x)

public defn clamp (n:FloField, mn:FloField, mx:FloField) -> FloField :
  min(mx, max(mn, n))

public deftype Vec3Field <: Hashable & Equalable
public defmulti x (v:Vec3Field) -> FloField
public defmulti y (v:Vec3Field) -> FloField
public defmulti z (v:Vec3Field) -> FloField
public defmulti id (v:Vec3Field) -> Int

var nxt-id = -1

defn new-id () :
  nxt-id = nxt-id + 1
  nxt-id

public defn Vec3Field (x:FloField, y:FloField, z:FloField) :
  val id = new-id()
  new Vec3Field :
    defmethod x (this) : x
    defmethod y (this) : y
    defmethod z (this) : z
    defmethod id (this) : id
    defmethod hash (this) : id

defmethod equal? (a:Vec3Field, b:Vec3Field) -> True|False :
  x(a) == x(b) and y(a) == y(b) and z(a) == z(b) 

public defn lit (v:V3f) -> Vec3Field :
  Vec3Field(lit(x(v)), lit(y(v)), lit(z(v)))

public defn Vec3Field (n:FloField) -> Vec3Field :
  Vec3Field(n, n, n)

defmethod print (o:OutputStream, v:Vec3Field) :
  print(o, "Vec3Field(%_, %_, %_)" % [x(v), y(v), z(v)])

public deftype Vec2Field <: Vec3Field

public defn Vec2Field (x:FloField, y:FloField) :
  new Vec2Field :
    defmethod x (this) : x
    defmethod y (this) : y
    defmethod z (this) : lit(0.0)

defmethod print (o:OutputStream, v:Vec2Field) :
  print(o, "Vec2Field(%_, %_)" % [x(v), y(v)])

public defn Vec2Field (n:FloField) -> Vec2Field :
  Vec2Field(n, n)

public defn xy (v:Vec3Field) -> Vec2Field :
  Vec2Field(x(v), y(v))

public defn yz (v:Vec3Field) -> Vec2Field :
  Vec2Field(y(v), z(v))

public defn xz (v:Vec3Field) -> Vec2Field :
  Vec2Field(x(v), z(v))

public defn abs (a:Vec3Field) -> Vec3Field :
  Vec3Field(abs(x(a)), abs(y(a)), abs(z(a)))

public defn max (a:Vec3Field, b:FloField) -> Vec3Field :
  Vec3Field(max(x(a), b), max(y(a), b), max(z(a), b))

public defn max (a:Vec3Field, b:Vec3Field) -> Vec3Field :
  Vec3Field(max(x(a), x(b)), max(y(a), y(b)), max(z(a), z(b)))

public defn min (a:Vec3Field, b:FloField) -> Vec3Field :
  Vec3Field(min(x(a), b), min(y(a), b), min(z(a), b))

public defn min (a:Vec3Field, b:Vec3Field) -> Vec3Field :
  Vec3Field(min(x(a), x(b)), min(y(a), y(b)), min(z(a), z(b)))

public defn plus (a:Vec3Field, b:Vec3Field) -> Vec3Field :
  Vec3Field(x(a) + x(b), y(a) + y(b), z(a) + z(b))

public defn minus (a:Vec3Field, b:Vec3Field) -> Vec3Field :
  Vec3Field(x(a) - x(b), y(a) - y(b), z(a) - z(b))

public defn negate (a:Vec3Field) -> Vec3Field :
  Vec3Field((- x(a)), (- y(a)), (- z(a)))

public defn times (s:FloField, v:Vec3Field) -> Vec3Field :
  Vec3Field(s * x(v), s * y(v), s * z(v))

public defn times (a:Vec3Field, b:Vec3Field) -> Vec3Field :
  Vec3Field(x(a) * x(b), y(a) * y(b), z(a) * z(b))

public defn dot (a:Vec3Field, b:Vec3Field) -> FloField :
  x(a) * x(b) + y(a) * y(b) + z(a) * z(b)

public defn len (v:Vec3Field) -> FloField :
  sqrt(dot(v, v))

public defn normalize (v:Vec3Field) -> Vec3Field :
  v / len(v)

public defn divide (a:Vec3Field, b:FloField) -> Vec3Field :
  Vec3Field(x(a) / b, y(a) / b, z(a) / b)

public defn divide (a:Vec3Field, b:Vec3Field) -> Vec3Field :
  Vec3Field(x(a) / x(b), y(a) / y(b), z(a) / z(b))

public defn modulo (a:Vec3Field, b:Vec3Field) -> Vec3Field :
  Vec3Field(y(a) * z(b) - z(a) * y(b),
      z(a) * x(b) - x(a) * z(b),
      x(a) * y(b) - y(a) * x(b))

public defn with-xyz (mat:Mat44, f:(Vec3Field) -> Vec3Field, s:Shape) -> Shape :
  Shape(fn (p): fab(s, f(p)), mat * bounds(s), to-tuple $ seq({mat * _} points(s)))

public defmethod mov (dp:V3f, s:Shape) -> Shape :
  with-xyz(mov-mat44(dp), fn (p): p - lit(dp), s)

;; public defn mov (dx:FloField, dy:FloField, f:Shape) -> FloField :
;;   mov(dx, dy, lit(0.0), f)

public defn degrees-to-radians (d:Float) -> Float :
  d * 180.0f / to-float(PI-F)

public defn radians-to-degrees (a:Float) -> Float :
  a * to-float(PI-F) / 180.0f

public defn rot-x (d:Float, s:Shape) -> Shape :
  val a = degrees-to-radians(d)
  val [ca, sa] = [cos(a), sin(a)]
  with-xyz(rot-mat44(V3f(1.0f, 0.0f, 0.0f), a),
           fn (p): Vec3Field(x(p), lit(ca) * y(p) + lit(sa) * z(p), lit((- sa)) * y(p) + lit(ca) * z(p)), s)

public defn rot-y (d:Float, s:Shape) -> Shape :
  val a = degrees-to-radians(d)
  val [ca, sa] = [cos(a), sin(a)]
  with-xyz(rot-mat44(V3f(0.0f, 1.0f, 0.0f), a),
           fn (p): Vec3Field(lit(ca) * x(p) + lit(sa) * z(p), y(p), lit((- sa)) * x(p) + lit(ca) * z(p)), s)

public defn rot-z (d:Float, s:Shape) -> Shape :
  val a = degrees-to-radians(d)
  val [ca, sa] = [cos(a), sin(a)]
  with-xyz(rot-mat44(V3f(0.0f, 0.0f, 1.0f), a),
           fn (p): Vec3Field(lit(ca) * x(p) + lit(sa) * y(p), lit((- sa)) * x(p) + lit(ca) * y(p), z(p)), s)

public defn reflect-x (s:Shape) -> Shape :
  with-xyz(mag-mat44(V3f(-1.0f, 1.0f, 1.0f)), fn (p): Vec3Field((- x(p)), y(p), z(p)), s)

public defn reflect-y (s:Shape) -> Shape :
  with-xyz(mag-mat44(V3f( 1.0f,-1.0f, 1.0f)), fn (p): Vec3Field(x(p), (- y(p)), z(p)), s)

public defn reflect-z (s:Shape) -> Shape :
  with-xyz(mag-mat44(V3f( 1.0f, 1.0f,-1.0f)), fn (p): Vec3Field(x(p), y(p), (- z(p))), s)

public defn reflect-xy (s:Shape) -> Shape :
  with-xyz(reflect-xy-mat44(), fn (p): Vec3Field(y(p), x(p), z(p)), s)

public defn reflect-xz (s:Shape) -> Shape :
  with-xyz(reflect-xz-mat44(), fn (p): Vec3Field(z(p), y(p), x(p)), s)

public defn reflect-yz (s:Shape) -> Shape :
  with-xyz(reflect-yz-mat44(), fn (p): Vec3Field(x(p), z(p), y(p)), s)

public defn mag (fac:Float, s:Shape) -> Shape :
  with-xyz(mag-mat44(fac), fn (p): p / lit(fac), s)

public defn mag1 (sa:Float, s:Shape) -> Shape :
  with-xyz(mag-mat44(sa), fn (p): p / lit(sa), s)

public defn mag (fac:V3f, s:Shape) -> Shape :
  with-xyz(mag-mat44(fac), fn (p): p / lit(fac), s)

public defn mag-x (sx:Float, s:Shape) -> Shape :
  with-xyz(mag-mat44(V3f(sx, 1.0f, 1.0f)), fn (p): Vec3Field(x(p) / lit(sx), y(p), z(p)), s)

public defn mag-y (sy:Float, s:Shape) -> Shape :
  with-xyz(mag-mat44(V3f(1.0f, sy, 1.0f)), fn (p): Vec3Field(x(p), y(p) / lit(sy), z(p)), s)

public defn mag-z (sz:Float, s:Shape) -> Shape :
  with-xyz(mag-mat44(V3f(1.0f, 1.0f, sz)), fn (p): Vec3Field(x(p), y(p), z(p) / lit(sz)), s)

defn shear-x-y (ymin:Float, ymax:Float, dx0:Float, dx1:Float, s:Shape) -> Shape :
  defn xf (p) :
    val f = (y(p) - lit(ymin)) / (lit(ymax) - y(p))
    Vec3Field(x(p) - lit(dx0) * (lit(1.0) - f) - lit(dx1) * f, y(p), z(p))  
  with-xyz(shear-x-y-mat44(ymin, ymax, dx0, dx1), xf, s)

public defn shear-x-y (h:Float, dx0:Float, dx1:Float, s:Shape) -> Shape :
  shear-x-y(dim-min(h), dim-max(h), dx0, dx1, s)

;; TODO : UPDATE BOUNDS
defn taper-x-y (ymin:Float, ymax:Float, s0:Float, s1:Float, s:Shape) -> Shape :
  defn xf (p) :
    val sc = lit(ymax - ymin) / ((lit(s1) * (y(p) - lit(ymin))) - (lit(s0) * (y(p) - lit(ymax))))
    Vec3Field(x(p) * sc, y(p), z(p))
  with-xyz(id-mat44(), xf, s)

;; TODO : UPDATE BOUNDS
defn taper-xy-z (zmin:Float, zmax:Float, s0:Float, s1:Float, s:Shape) -> Shape :
  defn xf (p) :
    val sc = lit(zmax - zmin) / ((lit(s1) * (z(p) - lit(zmin))) - (lit(s0) * (z(p) - lit(zmax))))
    Vec3Field(x(p) * sc, y(p) * sc, z(p))
  with-xyz(id-mat44(), xf, s)

public defn taper-xy-z (h:Float, s0:Float, s1:Float, s:Shape) -> Shape :
  taper-xy-z(dim-min(h), dim-max(h), s0, s1, s)

;; TODO : UPDATE BOUNDS
public defn revolve-y (s:Shape) -> Shape :
  with-xyz(id-mat44(), fn (p): Vec3Field(sqrt(sqr(x(p)) + sqr(z(p))), y(p), z(p)), s)

;; TODO : UPDATE BOUNDS
public defn revolve-x (s:Shape) -> Shape :
  with-xyz(id-mat44(), fn (p): Vec3Field(x(p), sqrt(sqr(y(p)) + sqr(z(p))), z(p)), s)

;; TODO : UPDATE BOUNDS
public defn xy (z:Float, s:Shape) -> Shape :
  with-xyz(id-mat44(), fn (p): Vec3Field(x(p), y(p), lit(z)), s)

public defn xy (s:Shape) -> Shape : xy(0.0f, s)

public defn circle (d:Float) -> Shape :
  val r = d * 0.5f
  Shape(fn (p): len(xy(p)) - lit(r), Box(V3f((- r), (- r), FLOAT-MIN), V3f(r, r, FLOAT-MAX)))

;; public defn circle (x:FloField, y:FloField, r:FloField) -> FloField :
;;   mov(x, y, {circle(r)})

public defn sphere (d:Float) -> Shape :
  val r = d * 0.5f
  Shape(fn (p): len(p) - lit(r), Box(V3f((- r), (- r), (- r)), V3f(r, r, r)))

;; public defn sphere (x:FloField, y:FloField, z:FloField, r:FloField) -> FloField :
;;   mov(x, y, z, {circle(r)})

public defn bit-or (a:Shape, b:Shape) -> Shape :
  Shape(fn (p): min(fab(a, p), fab(b, p)), bounds(a) | bounds(b),
        to-tuple $ cat(points(a), points(b)))

public defn union (args:Seqable<Shape>) -> Shape :
  reduce(bit-or, empty(), args)

public defn bit-and (a:Shape, b:Shape) -> Shape :
  Shape(fn (p): max(fab(a, p), fab(b, p)), bounds(a) & bounds(b),
        to-tuple $ cat(points(a), points(b)))

public defn intersection (args:Seqable<Shape>) -> Shape :
  reduce(bit-and, args)

public defn invert (s:Shape) -> Shape :
  Shape(fn (p): (- fab(s, p)), inf-box())

public defn rem (a:Shape, b:Shape) -> Shape :
  Shape(a & invert(b), bounds(a), points(a))

public defn rem (a:Shape, args:Seqable<Shape>) -> Shape :
  rem(a, union(args))

public defn rem (shapes:Seqable<Shape>) -> Shape :
  val s = to-seq(shapes)
  rem(next(s), s)

public defn offset (s:Shape, o:Float) -> Shape :
  Shape(fn (p): fab(s, p) - lit(o), fatten(bounds(s), o), points(s))
  
public defn clearance (a:Shape, b:Shape, o:Float) -> Shape :
  Shape(a & invert(offset(b, (- o))), bounds(a), points(a))
  
public defn shell (s:Shape, o:Float) -> Shape :
  clearance(s, s, o)
  
public defn blend (a:Shape, b:Shape, m:Float) -> Shape :
  val joint = a | b
  val fillet = Shape(fn (p): sqrt(abs(fab(a, p))) + sqrt(abs(fab(b, p))) - lit(m), bounds(a) | bounds(b))
  joint | fillet
  
public defn morph (a:Shape, b:Shape, m:Float) -> Shape :
  Shape(fn (p): fab(a, p) * (lit(1.0) - lit(m)) + fab(b, p) * lit(m), bounds(a) | bounds(b))
  
defn rect (xmin:Float, ymin:Float, xmax:Float, ymax:Float) -> Shape :
  val b = Box(V3f(xmin, ymin, FLOAT-MIN), V3f(xmax, ymax, FLOAT-MAX))
  Shape(fn (p): max(max(lit(xmin) - x(p), x(p) - lit(xmax)), max(lit(ymin) - y(p), y(p) - lit(ymax))),
        Box(V3f(xmin, ymin, FLOAT-MIN), V3f(xmax, ymax, FLOAT-MAX)))

public defn dim-min (d:Float) -> Float : d * -0.5f
public defn dim-max (d:Float) -> Float : d *  0.5f

public defn dim-min (dim:V3f) -> V3f : V3f(dim-min(x(dim)), dim-min(y(dim)), dim-min(z(dim)))
public defn dim-max (dim:V3f) -> V3f : V3f(dim-max(x(dim)), dim-max(y(dim)), dim-max(z(dim)))

public defn rect (w:Float, h:Float) -> Shape :
  rect(dim-min(w), dim-min(h), dim-max(w), dim-max(h))

public defn rect (v0:V3f, v1:V3f, d:Float) -> Shape :
  val v = v1 - v0
  val a = atan2(y(v),x(v))
  mov(0.5f * (v0 + v1), rot-z(radians-to-degrees(a), rect(magnitude(v) + d, d)))

public defn square (d:Float) -> Shape :
  rect(d, d)

public defn edge (v0:V3f, v1:V3f) -> Shape :
  Shape(fn (p): lit(y(v1) - y(v0)) * (x(p) - lit(x(v0))) - lit(x(v1) - x(v0)) * (y(p) - lit(y(v0))),
        Box(v0) | Box(v1))

public defn convex (pts:Tuple<V3f>) -> Shape :
  val edges = for i in 0 to length(pts) seq :
                edge(pts[i], pts[(i + 1) % length(pts)])
  reduce(fn (a:Shape, b:Shape): a & b, edges)

public defn to-field2 (m:Mesh) -> Shape :
  val verts = vertices(m)
  union(for face in faces(m) seq :
          triangle(verts[face[0]], verts[face[1]], verts[face[2]]))

public defn to-field2 (p:Polygon) -> Shape :
  to-field2(triangulate(p))

public defn triangle (a:V3f, b:V3f, c:V3f) -> Shape :
  convex([a, b, c])

defn extrude (zmin:Float, zmax:Float, shape:Shape) -> Shape :
  val b = bounds(shape)
  Shape(fn (p): max(fab(shape, p), max(lit(zmin) - z(p), z(p) - lit(zmax))),
        Box(V3f(x(lo(b)), y(lo(b)), zmin), V3f(x(hi(b)), y(hi(b)), zmax)))

public defn extrude (h:Float, shape:Shape) -> Shape :
  extrude(dim-min(h), dim-max(h), shape)

;;; DEPRECATE
defn cube (xmin:Float, ymin:Float, zmin:Float, xmax:Float, ymax:Float, zmax:Float) -> Shape :
  extrude(zmin, zmax, rect(xmin, ymin, xmax, ymax))

;;; DEPRECATE
public defn cube (w:Float, h:Float, d:Float) -> Shape :
  cube(dim-min(w), dim-min(h), dim-min(d), dim-max(w), dim-max(h), dim-max(d))

public defn cube (d:Float) -> Shape :
  cube(d, d, d)

public defn cube (xy:Float, z:Float) -> Shape :
  cube(xy, xy, z)

public defn cube (v:V3f) -> Shape :
  cube(x(v), y(v), z(v))

public defn box (dims:V3f) -> Shape :
  defn fab (p) :
    val d = abs(p) - lit(0.5f * dims)
    min(max(x(d),max(y(d),z(d))),lit(0.0)) + len(max(d,lit(0.0)))  
  Shape(fab, dims-to-box(dims))

public defn round-box (dims:V3f, r:Float) -> Shape :
  Shape(fn (p): len(max(abs(p) - lit(0.5) * lit(dims), lit(0.0))) - lit(r), dims-to-box(dims))

public defn cylinder (d:Float, h:Float) -> Shape :
  extrude(h, circle(d))

public defn capsule (a:V3f, b:V3f, d:Float) -> Shape :
  val r  = 0.5f * d
  defn fab (p) :
    val pa = p - lit(a)
    val ba = b - a
    val h  = clamp(dot(pa, lit(ba)) / lit(dot(ba, ba)), lit(0.0), lit(1.0))
    len(pa - h * lit(ba)) - lit(r)
  Shape(fab, fatten(Box(a, a) | Box(b, b), r))

public defn capsule (d:Float, h:Float) -> Shape :
  val r = 0.5f * h
  cylinder(d, h) | mov-z(r, sphere(d)) | mov-z((- r), sphere(d))

public defn capsule2 (a:V3f, b:V3f, d:Float) -> Shape :
  val r  = 0.5f * d
  defn fab (p) :
    val pa = xy(p) - lit(a)
    val ba = b - a
    val h  = clamp(dot(pa, lit(ba)) / lit(dot(ba, ba)), lit(0.0), lit(1.0))
    len(pa - h * lit(ba)) - lit(r)
  Shape(fab, fatten(Box(a, a) | Box(b, b), r))

public defn thicken (segments:Seqable<[V3f, V3f]>, f:(V3f, V3f, Float) -> Shape, d:Float) -> Shape :
  val caps = for [v0, v1] in segments seq : f(v0, v1, d)
  reduce(fn (a:Shape, b:Shape): a | b, caps)

public defn thicken (g:PolyLine|Contour|Polygon, f:(V3f, V3f, Float) -> Shape, d:Float) -> Shape :
  thicken(segments(g), f, d)

public defn cone (d:Float, h:Float) -> Shape :
  Shape(taper-xy-z(h, 1.0f, 0.0f, cylinder(d, h)),
        dims-to-box(V3f(d, d, h)))

public defn pyramid (d:Float, h:Float) -> Shape :
  Shape(taper-xy-z(h, 1.0f, 0.0f, extrude(h, rect(d, d))),
        dims-to-box(V3f(d, d, h)))

public defn torus (D:Float, d:Float) -> Shape :
  Shape(fn (p): len(Vec2Field(lit(D * 0.5f) - len(xy(p)), z(p))) - lit(d * 0.5f),
        dims-to-box(V3f(D + d, D + d, d)))

public defn space (gdims:V3f, shape:Shape) :
  val gratio = gdims / dims(bounds(shape))
  val fac    = min(gratio)
  mag1(fac, shape)

public defn empty () : Shape(lit{FLOAT-MAX}, min-box())
public defn full () : Shape(lit{FLOAT-MIN}, inf-box())

public defn space-x (gdim:Float, shape:Shape) : mag1(gdim / x(dims(bounds(shape))), shape)
public defn space-y (gdim:Float, shape:Shape) : mag1(gdim / y(dims(bounds(shape))), shape)
public defn space-z (gdim:Float, shape:Shape) : mag1(gdim / z(dims(bounds(shape))), shape)

public defmulti spacer<?T> (g:?T&Poseable, dims:V3f) -> T
defmethod spacer (g:Shape, gdims:V3f) : Shape(lit{FLOAT-MAX}, Box(dim-min(gdims), dim-max(gdims)))
defmethod spacer (g:Layer, dims:V3f) : Layer(BLACK, spacer(empty(), dims))
defmethod spacer (g:Block, dims:V3f) : Block(BLACK, spacer(empty(), dims))
defmethod spacer (g:Layout, dims:V3f) : Layout([Block(BLACK, spacer(empty(), dims))])

public defn spacer-x<?T> (gdim:Float, g:?T&Poseable) : spacer(g, V3f(gdim, 0.0f, 0.0f))
public defn spacer-y<?T> (gdim:Float, g:?T&Poseable) : spacer(g, V3f(0.0f, gdim, 0.0f))
public defn spacer-z<?T> (gdim:Float, g:?T&Poseable) : spacer(g, V3f(0.0f, 0.0f, gdim))

public defn spacer-x (gdim:Float) : spacer-x(gdim, empty())
public defn spacer-y (gdim:Float) : spacer-y(gdim, empty())
public defn spacer-z (gdim:Float) : spacer-z(gdim, empty())

public defn stack-idx<?T> (ishapes:Seqable<?T&Poseable>, idx:Int, dir:Float) -> Seq<T> :
  val shapes = to-tuple(ishapes)
  val tot = reduce(plus, for shape in shapes seq : dims(bounds(shape))[idx])
  var tot-fac = 0.0f
  val res =
    generate<T&Poseable> :
      for (child in shapes, i in 0 to false) do :
        val now-fac = dims(bounds(child))[idx] / tot
        val ctr     = center(bounds(child))[idx]
        val amount  = dir * (tot / 2.0f - (tot-fac + now-fac / 2.0f) * tot) - ctr
        val del     = amount * V3f-unit(idx)
        yield(mov(del, child))
        tot-fac = tot-fac + now-fac
  filter({ volume(dims(bounds(_))) > 0.0f }, res)

public defn stack-x<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  stack-idx(shapes, 0,  1.0f)

public defn stack-y<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  stack-idx(shapes, 1,  1.0f)

public defn stack-z<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  stack-idx(shapes, 2,  1.0f)

public deftype AnyGlue <: Poseable
public defmulti amount (g:AnyGlue) -> Float

public deftype Glue <: AnyGlue & Shape

public defn glue-amount<?T> (shape:?T&Poseable) -> Float :
  match(shape) :
    (g:AnyGlue) : amount(g)
    (s)         : 0.0f

public defn Glue (amount:Float) :
  new Glue :
    defmethod fabber (this): fn (p:Vec3Field) : lit(FLOAT-MAX)
    defmethod bounds (this): Box(V3f(0.0f, 0.0f, 0.0f), V3f(0.0f, 0.0f, 0.0f))
    defmethod amount (this): amount

public deftype RealGlue <: AnyGlue & RealPoseable
defmulti glue (g:RealGlue) -> Glue

defmethod bounds (g:RealGlue) : bounds(glue(g))
defmethod amount (g:RealGlue) : amount(glue(g))

public deftype LayerGlue <: RealGlue & Layer

public defn LayerGlue (glue:Glue) :
  new LayerGlue :
    defmethod glue (this) : glue
    defmethod color (this): V4f(0.0f, 0.0f, 0.0f, 0.0f)

public deftype BlockGlue <: RealGlue & Block

public defn BlockGlue (glue:Glue) :
  new BlockGlue :
    defmethod glue (this) : glue

public deftype LayoutGlue <: RealGlue & Layout

public defn LayoutGlue (glue:Glue) :
  new LayoutGlue :
    defmethod glue (this) : glue

public defmulti glue-of<?T> (s:?T&Poseable, a:Float) -> T
defmethod glue-of (s:Shape, a:Float) -> Shape : Glue(a)
defmethod glue-of (s:Layer, a:Float) -> Layer : LayerGlue(Glue(a))
defmethod glue-of (s:Block, a:Float) -> Block : BlockGlue(Glue(a))
defmethod glue-of (s:Layout, a:Float) -> Layout : LayoutGlue(Glue(a))

defn glue-when<?T> (zero?:True|False, shapes:Seqable<?T&Poseable>) -> Seq<T> :
  generate<T> :
    for (shape in shapes, i in 0 to false) do :
      if zero? or i != 0: yield(glue-of(shape, 1.0f))
      yield(shape)

public defn glue-even<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  glue-when(true, shapes)

public defn glue-odd<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  glue-when(false, shapes)

public defn glue<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  glue-odd(shapes)

public defn assign-glue-idx<?T> (ishapes:Seqable<?T&Poseable>, target:Float, idx:Int) -> Seq<T> :
  val shapes = to-tuple(ishapes)
  val tot = reduce(plus, for shape in shapes seq : dims(bounds(shape))[idx])
  val glue-tot = reduce(plus, for shape in shapes seq : glue-amount(shape))
  val gap-tot = (target - tot)
  for shape in shapes seq :
    match(shape) :
      (g:AnyGlue&T) :
        val s = (amount(g) / glue-tot) * gap-tot * V3f-unit(idx)
        spacer(shape, s)
      (s)           : s

public defn stack-idx<?T> (d:Float, idx:Int, shapes:Seqable<?T&Poseable>) -> Seq<T> :
  stack-idx(assign-glue-idx(shapes, d, idx), idx, 1.0f)

public defn stack-x<?T> (w:Float, shapes:Seqable<?T&Poseable>) -> Seq<T> :
  stack-x(assign-glue-idx(shapes, w, 0))

public defn stack-y<?T> (h:Float, shapes:Seqable<?T&Poseable>) -> Seq<T> :
  stack-y(assign-glue-idx(shapes, h, 1))

public defn stack-z<?T> (d:Float, shapes:Seqable<?T&Poseable>) -> Seq<T> :
  stack-z(assign-glue-idx(shapes, d, 2))

defn align-it<?T> (ishapes:Seqable<?T&Poseable>, value:(Box) -> Float, mov:(Float, T) -> T) -> Seq<T> :
  val shapes = to-tuple(ishapes)
  val target = reduce(union, seq(bounds, shapes))
  ;; val target = bounds(shapes[0])
  for (child in shapes) seq :
    mov(value(target) - value(bounds(child)), child)

public defn attach<?T> (src:?T&Poseable, spos:V3f, dst:?T&Poseable, dpos:V3f) -> Seqable<T> :
  [mov(dpos - spos, src), dst]

public defn attach<?T> (src:?T&Poseable, si:Int, dst:?T&Poseable, di:Int) -> Seqable<T> :
  attach(src, points(src)[si], dst, points(dst)[di])

public defn align-min-x<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  align-it(shapes, { x(lo(_)) }, mov-x)

public defn align-max-x<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  align-it(shapes, { x(hi(_)) }, mov-x)

public defn align-min-y<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  align-it(shapes, { y(lo(_)) }, mov-y)

public defn align-max-y<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  align-it(shapes, { y(hi(_)) }, mov-y)

public defn align-min-z<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  align-it(shapes, { z(lo(_)) }, mov-z)

public defn align-max-z<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  align-it(shapes, { z(hi(_)) }, mov-z)

defn jit-shape (s:Shape) -> BoundedTree :
  val e = fab(s, Vec3Field(fab-x(), fab-y(), fab-z()))
  ;; println-all(["E = " e])
  BoundedTree(bounds(s), tree(e))

defn jit-layer (l:Layer) -> TreeLayer :
  TreeLayer(pos(l), color(l), jit-shape(shape(l)))

defn jit-block (b:Block) -> TreeBlock :
  TreeBlock(to-tuple $ seq(jit-layer, layers(b)))

defn jit-layout (l:Layout) -> TreeLayout :
  TreeLayout(to-tuple $ seq(jit-block, blocks(l)))

public defn jit (g:Geom) -> Geom :
  match(g) :
    (s:Shape) :  jit-shape(s)
    (l:Layer) :  jit-layer(l)
    (b:Block) :  jit-block(b)
    (l:Layout) : jit-layout(l)
    (geom) :     geom

public defn slice (z:Float, s:Shape) -> Polygon :
  val bt = jit(s) as BoundedTree
  val bds = Box(xy(lo(bounds(s)) + V3f(0.0f, 0.0f, z)), xy(hi(bounds(s)) + V3f(0.0f, 0.0f, z)))
  val poly = tree-render-slice(tree(bt), bds, 50.0f)
  poly

public defn save (z:Float, filename:String, s:Shape) -> False :
  val bt = jit(s) as BoundedTree
  tree-export-slice(tree(bt), filename, bounds(s), 50.0f)

public defn save (filename:String, s:Shape) -> False :
  val bt = jit(s) as BoundedTree
  tree-export-mesh(tree(bt), filename, bounds(s), 50.0f)

;;;

val big = 1.0e6f

public defn join-pieces (a:Shape, b:Shape, nslots:Int) -> [Shape, Shape] :
  val overlap = intersection $ [a, b]
  val dims    = dims(bounds(overlap))
  val idx     = max-idx(dims)
  val num     = to-int $ round $ (to-float(nslots) / 2.0f)
  val tdims   = set-elt(V3f-fill(big), idx, dims[idx] / to-float(nslots))
  val tooth   = cube(tdims)
  val tooths  = union $ stack-idx(dims[idx], idx, glue-when(nslots % 2 == 0, seq({ tooth }, 0 to num)))
  ;; println-all(["NUM " num " NSLOTS " nslots " DIMS " dims[idx] " TDIMS " tdims[idx] " TD " dims[idx] / to-float(nslots)])
  val teeth   = overlap & tooths
  val pa      = rem(a, teeth)
  val pb      = rem(b, pa)
  [pa, pb]

public defn all-combos (a:Seqable<Int>, b:Seqable<Int>) -> Seqable<[Int, Int]> :
  generate<[Int, Int]> :
    for i in a do :
      for j in b do :
        yield([i, j])

defn captured? (b1:Box, b2:Box) -> True|False :
  defn any-captured? (i:Box, a:Box) :
    defn captured-on? (i:Box, a:Box, d:Int) :
      abs(lo(i)[d] - lo(a)[d]) > 0.0f and abs(hi(a)[d] - hi(i)[d]) > 0.0f
    any?(captured-on?{i, a, _}, 0 to 3)
  val intersection = b1 & b2
  any-captured?(intersection, b1) and any-captured?(intersection, b2)

public defn join-pieces (elts:Seqable<Shape>, default-num:Int, nums:Tuple<KeyValue<[Int,Int],Int>>, sames:Tuple<[Int, Int, V3f]>) :
  defn lookup-num (i:Int, j:Int) -> Int :
    label<Int> return :  
      for kv in nums do :
        val [ki, kj] = key(kv)
        if (ki == i and kj == j) or (ki == j and kj == i) :
          return(value(kv))
      default-num
  val pieces = to-array<Shape> $ elts
  defn update (k:Int, nk:Shape) :
    pieces[k] = nk
    for [i, j, d] in sames do :
      if i == k :
        println-all(["SAME UPDATE " j " <- " i])
        pieces[j] = pieces[j] & mov(d, pieces[i])
  for i in 0 to length(pieces) do :
    for j in (i + 1) to length(pieces) do :
      val [bi, bj] = [bounds(pieces[i]), bounds(pieces[j])]
      if not empty?(bi & bj) :
        val num = 2 when captured?(bi, bj) else lookup-num(i, j)
        println-all(["I " i " J " j " NUM " num])
        val [ni, nj] = join-pieces(pieces[i], pieces[j], num)
        update(i, ni)
        update(j, nj)
  pieces

public defn join-pieces (elts:Seqable<Shape>, num:Int) :
  join-pieces(elts, num, [], [])

;; TODO: LIMITED TO AXIS ALIGNED SHAPES
public defn smash (s:Shape) -> Shape :
  val bb    = bounds(s)
  val dims  = dims(bb)
  val idx   = min-idx(dims)
  val ctr   = center(bb)
  defn rot (s) : if idx == 0 : reflect-xz(s) else if idx == 1 : reflect-yz(s) else : s
  rot(mov((- ctr), s))

public defn nest (pcs:Seqable<Shape>, width:Float, space:Float) -> Layout :
  val spcs = lazy-qsort({ area(dims(bounds(_))) }, pcs)
  ;; val lay  = stack-x(seq(Block, join(spcs, spacer-x(space))))
  ;; cat-all(seq(shapes, lay))
  val row  = Vector<Shape>()
  val rows = generate<Tuple<Shape>> :
    for pc in spcs do :
      val off = reduce(plus, 0.0f, join(seq({ x(dims(bounds(_))) }, row), space))
      if off > width :
        yield(to-tuple $ row)
        clear(row)
      add(row, pc)
    if length(row) > 0 : yield(to-tuple $ row)
  val lay = stack-y(join(for row in rows seq: Layout(stack-x(seq(Block, join(row, spacer-x(space))))),
                    Layout([ Block(spacer-y(space)) ])))
  Layout(cat-all(seq(blocks, lay)))

defn num-to-bits (num:Int) -> Tuple<Int> :
  to-tuple $ for i in 2 through 0 by -1 seq : (num >> i) & 1

defn num-to-bitz (num:Int) -> Tuple<Tuple<Int>> :
  to-tuple $ for i in 2 through 0 by -1 seq : num-to-bits((num >> (i * 3)) & 7)

defn bits-to-num (bitz:Tuple<Int>) -> Int :
  reduce(fn (a, x): a * 2 + x, bitz)

defn bitz-to-num (bitz:Tuple<Tuple<Int>>) -> Int :
  reduce(fn (a, x): a * 8 + x, seq(bits-to-num, bitz))

defn canonicalize-bits (bits:Tuple<Int>) -> Tuple<Int> :
  val rbits = [bits[2], bits[1], bits[0]]
  if bits-to-num(bits) < bits-to-num(rbits): bits else: rbits

defn canonicalize-bitz (bitz:Tuple<Tuple<Int>>) -> Tuple<Tuple<Int>> :
  to-tuple $ seq(num-to-bits, lazy-qsort(seq(bits-to-num, seq(canonicalize-bits, bitz))))

defn check (form:Tuple<Tuple<Int>>) -> True|False :
  defn boxed? (dim:Int, idx:Int) :
    label<True|False> return :
      val dn? = for i in idx through 0 by -1 any? :
        form[dim][i] == 1
      val up? = for i in (idx + 1) to 3 any? :
        form[dim][i] == 1
      dn? and up?
  label<True|False> return :
    for i in 0 to 2 do :
      for j in 0 to 2 do :
        for k in 0 to 2 do :
          if boxed?(0, i) and boxed?(1, j) and boxed?(2, k) :
            return(false)
    true

public defn all-forms () :
  val forms = HashTable<Int, Tuple<Tuple<Int>>>()
  for i in 0 to (2 << 8) do :
    val bitz  = num-to-bitz $ i
    val cbitz = canonicalize-bitz $ bitz
    val cnum  = bitz-to-num $ cbitz
    val ok?   = count({ _ == 0}, seq(bits-to-num, cbitz)) <= 1
    val ck?   = check(cbitz)
    if ck? and ok? and not key?(forms, cnum) :
      ;; println-all(["I " i " CNUM " cnum " BITZ " bitz " CBITZ " cbitz " CK? " ck? " OK? " ok? " KEY? " key?(forms, cnum)])
      forms[cnum] = cbitz
  forms

